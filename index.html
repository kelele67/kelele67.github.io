<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>树犹如此|人何以堪</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="做一个富有的废物">
<meta property="og:type" content="website">
<meta property="og:title" content="树犹如此|人何以堪">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="树犹如此|人何以堪">
<meta property="og:description" content="做一个富有的废物">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="树犹如此|人何以堪">
<meta name="twitter:description" content="做一个富有的废物">
  
  
    <link rel="icon" href="//favicon.png">
  
  <script src="/style.js"></script>
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="http://oe9uedqb2.bkt.clouddn.com/4D9F59FD6F416AF4A92C4B977580BD95.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">kelele67</a></h1>
		</hgroup>

		
		<p class="header-subtitle">做一个富有的废物</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="/about">关于本站</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">标签</a>
    			
    			
            
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/kelele67" title="github">github</a>
		        
					<a class="weibo" target="_blank" href="http://weibo.com/kelele67" title="weibo">weibo</a>
		        
					<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/liu-qi-21-51" title="zhihu">zhihu</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">kelele67</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="http://oe9uedqb2.bkt.clouddn.com/4D9F59FD6F416AF4A92C4B977580BD95.png" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">kelele67</h1>
			</hgroup>
			
			<p class="header-subtitle">做一个富有的废物</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/about">关于本站</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/kelele67" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/kelele67" title="weibo">weibo</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/liu-qi-21-51" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        
  
    <article id="airticle-深入 Lua Garbage Collector(三)" class="article article-type-airticle" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/14/深入 Lua Garbage Collector(三)/">深入 Lua Garbage Collector(三)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>

</p><h2 id="Lua-源码"><a href="#Lua-源码" class="headerlink" title="Lua 源码"></a>Lua 源码</h2><p>阅读的源码来自 <strong>lua-5.3.0</strong></p>
<h3 id="GC对象"><a href="#GC对象" class="headerlink" title="GC对象"></a>GC对象</h3><p>在 Lua 中，一共只有 9 种数据类型：</p>
<ul>
<li>nil </li>
<li>boolean </li>
<li>lightuserdata </li>
<li>number </li>
<li>string </li>
<li>table  </li>
<li>function  </li>
<li>userdata  </li>
<li>thread </li>
</ul>
<blockquote>
<p>其中，只有 <strong>string table function thread</strong> 四种在 <strong>vm</strong> 中以引用方式共享，是需要被 <strong>GC</strong> 管理回收的对象。其它类型都以值形式存在。</p>
<p>但在 <strong>Lua</strong> 的实现中，还有两种类型的对象需要被 <strong>GC</strong> 管理。分别是 <strong>proto</strong> （可以看作未绑定 upvalue 的函数）， <strong>upvalue</strong> （多个 upvalue 会引用同一个值）。</p>
</blockquote>
<h3 id="保存值的形式"><a href="#保存值的形式" class="headerlink" title="保存值的形式"></a>保存值的形式</h3><p>Lua 是以 union + type 的形式保存值</p>
<p>在lobject.h中<br>96行<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">** Union of all Lua values</div><div class="line">*/</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> Value Value;</div></pre></td></tr></table></figure></p>
<hr>
<p>101-108行<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">*</div><div class="line">** Tagged Values. This is the basic representation of values in Lua,</div><div class="line">** an actual value plus a tag with its type.</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> TValuefields    Value value_; int tt_</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> lua_TValue TValue;</div></pre></td></tr></table></figure></p>
<hr>
<p>279-286行<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">union</span> Value &#123;</div><div class="line">  GCObject *gc;    <span class="comment">/* collectable objects */</span></div><div class="line">  <span class="keyword">void</span> *p;         <span class="comment">/* light userdata */</span></div><div class="line">  <span class="keyword">int</span> b;           <span class="comment">/* booleans */</span></div><div class="line">  lua_CFunction f; <span class="comment">/* light C functions */</span></div><div class="line">  lua_Integer i;   <span class="comment">/* integer numbers */</span></div><div class="line">  lua_Number n;    <span class="comment">/* float numbers */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<hr>
<p>我们可以看到，Value 以 union 方式定义。如果是需要被 GC 管理的对象，就以 GCObject 指针形式保存，否则直接存值。在代码的其它部分，并不直接使用 Value 类型，而是 TValue 类型。它比 Value 多了一个类型标识。用 int tt 记录。通常的系统中，每个 TValue 长为 12 字节。</p>
<p>这里作者也有提到在 32 位系统下，为何不用某种 trick 把 type 压缩到前 8 字节内<br>具体考虑到的是可移植性的原因：</p>
<blockquote>
<p>Several dynamically-typed languages (e.g., the original implementa-<br>tion of Smalltalk80 [9]) use spare bits in each pointer to store the value’s type tag. This trick works in most machines because, due to alignment, the last two or three bits of a pointer are always zero, and therefore can be used for other purposes. However, this technique is neither portable nor implementable in ANSI C.<br>The C standard does not even ensures that a pointer ts in any integral type<br>and so there is no standard way to perform bit manipulation over pointers.</p>
</blockquote>
<h3 id="GCObject"><a href="#GCObject" class="headerlink" title="GCObject"></a>GCObject</h3><p>所有的 <strong>GCObject</strong> 都有一个相同的数据头，叫作 <strong>CommonHeader</strong> 。</p>
<p>在lobject.h里81行我们可以找到它的定义。使用宏定义的目的是为了能够包含在其他的object中。C 语言不支持结构的继承。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">** Common Header for all collectable objects (in macro form, to be</div><div class="line">** included in other objects)</div><div class="line">*/</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> CommonHeader    GCObject *next; lu_byte tt; lu_byte marked</span></div></pre></td></tr></table></figure></p>
<hr>
<blockquote>
<p>从这里我们可以看到：所有的 GCObject 都用一个单向链表串了起来。每个对象都以 tt 来识别其类型。marked 域用于标记清除的工作。</p>
<p>标记清除算法是一种简单的 GC 算法。每次 GC 过程，先以若干根节点开始，逐个把直接以及间接和它们相关的节点都做上标记。对于 Lua ，这个过程很容易实现。因为所有 GObject 都在同一个链表上，当标记完成后，遍历这个链表，把未被标记的节点一一删除即可。</p>
<p>实际上，Lua不只用一条链表来保存所有的 GCObject 。这是因为我们要清除的string table function thread中的 string 类型有其特殊性。<br>所有的 string 放在一张大的 hash 表中。它需要保证系统中不会有值相同的 string 被创建两份。<br>所以 string 是被单独管理的，而不串在 GCObject 的链表中。</p>
</blockquote>
<h3 id="lua-State"><a href="#lua-State" class="headerlink" title="lua_State"></a>lua_State</h3><p>lua_State 是 Lua 虚拟机的外在数据形式，取名 State 意为 Lua虚拟机 的当前状态。全局 State 引用了整个虚拟机的所有数据。而虚拟机的运转恰恰是 Lua 的核心部分。这个全局 State 定义在 lstate.h 中149-172行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">** 'per thread' state</div><div class="line">*/</div><div class="line"><span class="keyword">struct</span> lua_State &#123;</div><div class="line">  CommonHeader;</div><div class="line">  lu_byte status;</div><div class="line">  StkId top;  <span class="comment">/* first free slot in the stack */</span></div><div class="line">  global_State *l_G;</div><div class="line">  CallInfo *ci;  <span class="comment">/* call info for current function */</span></div><div class="line">  <span class="keyword">const</span> Instruction *oldpc;  <span class="comment">/* last pc traced */</span></div><div class="line">  StkId stack_last;  <span class="comment">/* last free slot in the stack */</span></div><div class="line">  StkId <span class="built_in">stack</span>;  <span class="comment">/* stack base */</span></div><div class="line">  UpVal *openupval;  <span class="comment">/* list of open upvalues in this stack */</span></div><div class="line">  GCObject *gclist;</div><div class="line">  <span class="keyword">struct</span> lua_State *twups;  <span class="comment">/* list of threads with open upvalues */</span></div><div class="line">  <span class="keyword">struct</span> lua_longjmp *errorJmp;  <span class="comment">/* current error recover point */</span></div><div class="line">  CallInfo base_ci;  <span class="comment">/* CallInfo for first level (C calling Lua) */</span></div><div class="line">  lua_Hook hook;</div><div class="line">  <span class="keyword">ptrdiff_t</span> errfunc;  <span class="comment">/* current error handling function (stack index) */</span></div><div class="line">  <span class="keyword">int</span> stacksize;</div><div class="line">  <span class="keyword">int</span> basehookcount;</div><div class="line">  <span class="keyword">int</span> hookcount;</div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> nny;  <span class="comment">/* number of non-yieldable calls in stack */</span></div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> nCcalls;  <span class="comment">/* number of nested C calls */</span></div><div class="line">  lu_byte hookmask;</div><div class="line">  lu_byte allowhook;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>一个完整的 lua 虚拟机在运行时，可有多个 lua_State ，即多个 thread 。它们会共享一些数据。这些数据放在 global_State *l_G 域中。其中自然也包括所有 GCobject 的链表。</p>
</blockquote>
<h3 id="allgc"><a href="#allgc" class="headerlink" title="allgc"></a>allgc</h3><blockquote>
<p>所有的 string 则以 stringtable 结构保存在 stringtable strt 域。string 的值类型为 TString ，它和其它 GCObject 一样，拥有 CommonHeader 。但需要注意，CommonHeader 中的 next 域却和其它类型的单向链表意义不同。它被挂接在 stringtable 这个 hash 表中。这也是我们之前有提到过的。</p>
<p>除 string 外的 GCObject 链表头放在 allgc 域中<br>在  lstate.h 122 行：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GCObject *allgc;  <span class="comment">/* list of all collectable objects */</span></div></pre></td></tr></table></figure></p>
</blockquote>
<hr>
<p>。初始化时，这个域被初始化为主线程。见 lstate.c 253 行，lua_newthread 函数中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* link it on list 'allgc' */</span></div><div class="line">L1-&gt;next = g-&gt;allgc;</div><div class="line">g-&gt;allgc = obj2gco(L1);</div></pre></td></tr></table></figure></p>
<hr>
<h3 id="link函数"><a href="#link函数" class="headerlink" title="link函数"></a>link函数</h3><p>每当一个新的 GCobject 被创建出来，都会被挂接到这个链表上，link函数主要是：</p>
<p>lgc.c 145-206行<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">luaC_barrier_</span> <span class="params">(lua_State *L, GCObject *o, GCObject *v)</span> </span>&#123;</div><div class="line">  global_State *g = G(L);</div><div class="line">  lua_assert(isblack(o) &amp;&amp; iswhite(v) &amp;&amp; !isdead(g, v) &amp;&amp; !isdead(g, o));</div><div class="line">  <span class="keyword">if</span> (keepinvariant(g))  <span class="comment">/* must keep invariant? */</span></div><div class="line">    reallymarkobject(g, v);  <span class="comment">/* restore invariant */</span></div><div class="line">  <span class="keyword">else</span> &#123;  <span class="comment">/* sweep phase */</span></div><div class="line">    lua_assert(issweepphase(g));</div><div class="line">    makewhite(g, o);  <span class="comment">/* mark main obj. as white to avoid other barriers */</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">luaC_upvalbarrier_</span> <span class="params">(lua_State *L, UpVal *uv)</span> </span>&#123;</div><div class="line">  global_State *g = G(L);</div><div class="line">  GCObject *o = gcvalue(uv-&gt;v);</div><div class="line">  lua_assert(!upisopen(uv));  <span class="comment">/* ensured by macro luaC_upvalbarrier */</span></div><div class="line">  <span class="keyword">if</span> (keepinvariant(g))</div><div class="line">    markobject(g, o);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">GCObject *<span class="title">luaC_newobj</span> <span class="params">(lua_State *L, <span class="keyword">int</span> tt, <span class="keyword">size_t</span> sz)</span> </span>&#123;</div><div class="line">  global_State *g = G(L);</div><div class="line">  GCObject *o = cast(GCObject *, luaM_newobject(L, novariant(tt), sz));</div><div class="line">  o-&gt;marked = luaC_white(g);</div><div class="line">  o-&gt;tt = tt;</div><div class="line">  o-&gt;next = g-&gt;allgc;</div><div class="line">  g-&gt;allgc = o;</div><div class="line">  <span class="keyword">return</span> o;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>upvalue 在 C 中类型为 UpVal ，也是一个 GCObject 。但这里被特殊处理。为什么会这样？因为 Lua 的 GC可以分步扫描。别的类型被新创建时，都可以直接作为一个白色节点（新节点）挂接在整个系统中。但 upvalue 却是对已有的对象的间接引用，不是新数据。一旦 GC 在 mark 的过程中（ gc 状态为 GCSpropagate ），则需增加屏障 luaC_barrier 。对于这个问题，会在以后详细展开。</p>
</blockquote>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.codingnow.com/2011/03/lua_gc_1.html" target="_blank" rel="external">云风的 BLOG</a></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/04/14/深入 Lua Garbage Collector(三)/" class="archive-article-date">
  	<time datetime="2017-04-14T14:20:02.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-04-14</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/gc/">gc</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/lua/">lua</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="airticle-深入 Lua Garbage Collector(二)" class="article article-type-airticle" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/14/深入 Lua Garbage Collector(二)/">深入 Lua Garbage Collector(二)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>

</p><p>这一篇我们主要介绍一下 <strong>Lua</strong> 的 <strong>GC</strong> 机制</p>
<h2 id="Lua垃圾回收器函数"><a href="#Lua垃圾回收器函数" class="headerlink" title="Lua垃圾回收器函数"></a>Lua垃圾回收器函数</h2><p><strong>Lua</strong> 提供了以下函数 <strong>collectgarbage ([opt [, arg]])</strong> 用来控制自动内存管理:</p>
<ul>
<li><p>collectgarbage(“collect”): 做一次完整的垃圾收集循环。通过参数 opt 它提供了一组不同的功能：</p>
</li>
<li><p>collectgarbage(“count”): 以 K 字节数为单位返回 Lua 使用的总内存数。 这个值有小数部分，所以只需要乘上 1024 就能得到 Lua 使用的准确字节数（除非溢出）。</p>
</li>
<li><p>collectgarbage(“restart”): 重启垃圾收集器的自动运行。</p>
</li>
<li><p>collectgarbage(“setpause”): 将 arg 设为收集器的 间歇率 。 返回 间歇率 的前一个值。</p>
</li>
<li><p>collectgarbage(“setstepmul”): 返回 步进倍率 的前一个值。</p>
</li>
<li><p>collectgarbage(“step”): 单步运行垃圾收集器。 步长”大小”由 arg 控制。 传入 0 时，收集器步进（不可分割的）一步。 传入非 0 值， 收集器收集相当于 Lua 分配这些多（K 字节）内存的工作。 如果收集器结束一个循环将返回 true 。</p>
</li>
<li><p>collectgarbage(“stop”): 停止垃圾收集器的运行。 在调用重启前，收集器只会因显式的调用运行。</p>
</li>
</ul>
<p>以下演示了一个简单的垃圾回收实例:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">mytable = &#123;<span class="string">"apple"</span>, <span class="string">"orange"</span>, <span class="string">"banana"</span>&#125;</div><div class="line"></div><div class="line"><span class="built_in">print</span>(<span class="built_in">collectgarbage</span>(<span class="string">"count"</span>))</div><div class="line"></div><div class="line">mytable = <span class="keyword">nil</span></div><div class="line"></div><div class="line"><span class="built_in">print</span>(<span class="built_in">collectgarbage</span>(<span class="string">"count"</span>))</div><div class="line"></div><div class="line"><span class="built_in">print</span>(<span class="built_in">collectgarbage</span>(<span class="string">"collect"</span>))</div><div class="line"></div><div class="line"><span class="built_in">print</span>(<span class="built_in">collectgarbage</span>(<span class="string">"count"</span>))</div></pre></td></tr></table></figure>
<hr>
<h2 id="基本算法"><a href="#基本算法" class="headerlink" title="基本算法"></a>基本算法</h2><p>基本算法就是我们之前的 <strong>Mark &amp; Sweep</strong></p>
<blockquote>
<p>首先，系统管理着所有已经创建了的对象。每个对象都有对其他对象的引用。 <strong>root</strong> 集合代表着已知的系统级别的对象引用。我们从 <strong>root</strong> 集合出发，就可以访问到系统引用到的所有对象。而没有被访问到的对象就是垃圾对象，需要被销毁。</p>
</blockquote>
<p>我们可以将所有对象分成三个状态：</p>
<p>①. White状态，也就是待访问状态。表示对象还没有被垃圾回收的标记过程访问到。</p>
<p>②. Gray状态，也就是待扫描状态。表示对象已经被垃圾回收访问到了，但是对象本身对于其他对象的引用还没有进行遍历访问。</p>
<p>③. Black状态，也就是已扫描状态。表示对象已经被访问到了，并且也已经遍历了对象本身对其他对象的引用</p>
<p>伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">当前所有对象都是White状态;  </div><div class="line">将root集合引用到的对象从White设置成Gray，并放到Gray集合中;  </div><div class="line">while(Gray集合不为空)  </div><div class="line">&#123;  </div><div class="line">    从Gray集合中移除一个对象O，并将O设置成Black状态;  </div><div class="line">    for(O中每一个引用到的对象O1) &#123;  </div><div class="line">        if(O1在White状态) &#123;  </div><div class="line">            将O1从White设置成Gray，并放到到Gray集合中；  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">for(任意一个对象O)&#123;  </div><div class="line">    if(O在White状态)  </div><div class="line">        销毁对象O;  </div><div class="line">    else  </div><div class="line">        将O设置成White状态;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="Incremental-Garbage-Collection"><a href="#Incremental-Garbage-Collection" class="headerlink" title="Incremental Garbage Collection"></a>Incremental Garbage Collection</h2><blockquote>
<p>上面的算法如果一次性执行，在对象很多的情况下，会执行很长时间，严重影响程序本身的响应速度。其中一个解决办法就是，可以将上面的算法分步执行，这样每个步骤所耗费的时间就比较小了。我们可以将上述算法改为以下下几个步骤:</p>
</blockquote>
<ol>
<li><p>首先标识所有的 <strong>root</strong> 对象</p>
</li>
<li><p>遍历访问所有的 <strong>gray</strong> 对象。如果超出了本次计算量上限，退出等待下一次遍历</p>
</li>
<li><p>销毁垃圾对象</p>
</li>
</ol>
<blockquote>
<p>在每个步骤之间，由于程序可以正常执行，所以会破坏当前对象之间的引用关系。black对象表示已经被扫描的对象，所以他应该不可能引用到一个white对象。当程序的改变使得一个black对象引用到一个white对象时，就会造成错误。解决这个问题的办法就是设置barrier。barrier在程序正常运行过程中，监控所有的引用改变。如果一个black对象需要引用一个white对象，存在两种处理办法：</p>
</blockquote>
<p>①. 将white对象设置成gray，并添加到gray列表中等待扫描。这样等于帮助整个GC的标识过程向前推进了一步。<br>②. 将black对象该回成gray，并添加到gray列表中等待扫描。这样等于使整个GC的标识过程后退了一步。</p>
<blockquote>
<p>这种垃圾回收方式被称为 <strong>Incremental Garbage Collection</strong> (简称为 <strong>IGC</strong> ， <strong>Lua</strong>所采用的就是这种方法。使用 <strong>IGC</strong> 并不是没有代价的。 <strong>IGC</strong> 所检测出来的垃圾对象集合比实际的集合要小，也就是说，有些在 <strong>GC</strong> 过程中变成垃圾的对象，有可能在本轮 <strong>GC</strong> 中检测不到。不过，这些残余的垃圾对象一定会在下一轮 <strong>GC</strong> 被检测出来，不会造成泄露。</p>
</blockquote>
<p>在下一篇中我们将会具体的来看一看 <strong>Lua</strong> 的 <strong>GC源码</strong></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/04/14/深入 Lua Garbage Collector(二)/" class="archive-article-date">
  	<time datetime="2017-04-14T02:50:02.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-04-14</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/gc/">gc</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/lua/">lua</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="airticle-深入 Lua Garbage Collector(一)" class="article article-type-airticle" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/13/深入 Lua Garbage Collector(一)/">深入 Lua Garbage Collector(一)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p></p><p><br>看到一个 <strong>Bob Nystrom</strong> 写的<a href="http://journal.stuffwithstuff.com/2013/12/08/babys-first-garbage-collector/" target="_blank" rel="external"> <strong>C</strong> 语言实现的 <strong>Garbage Collector</strong> </a></p>
<p>借着这个小程序顺便深入地了解一下Lua的垃圾回收机制</p>
<h2 id="Garbage-Collector算法小结"><a href="#Garbage-Collector算法小结" class="headerlink" title="Garbage Collector算法小结"></a>Garbage Collector算法小结</h2><p>这是之前做的一点小笔记：</p>
<p><img src="http://oe9uinblw.bkt.clouddn.com/WechatIMG1.jpeg" alt=""></p>
<h2 id="C-Garbage-Collector"><a href="#C-Garbage-Collector" class="headerlink" title="C Garbage Collector"></a>C Garbage Collector</h2><p>首先还是先来看看这个 <strong>C</strong> 的基本的垃圾回收器</p>
<h3 id="采用的算法"><a href="#采用的算法" class="headerlink" title="采用的算法"></a>采用的算法</h3><p>用的是经典的 <strong>Mark &amp; Sweep</strong> 算法</p>
<p>在上面的笔记里面已经介绍的很清楚了</p>
<p>该算法的工作原理几乎与我们对 <strong>可访问性(reachability)</strong> 的定义完全一样：</p>
<ol>
<li><p>从根节点开始，依次遍历整个对象图。每当你访问到一个对象，在上面设置一个 标记(mark) 位，置为 true 。</p>
</li>
<li><p>一旦搞定，找出所有标记位为 not 的对象集，然后删除它们。</p>
</li>
</ol>
<h3 id="对象对"><a href="#对象对" class="headerlink" title="对象对"></a>对象对</h3><p>要想清理垃圾，首先我们得制造点垃圾出来</p>
<p>所以假设我们正在为一种简单的语言编写一个解释器。它是动态的类型并且有两种类型的变量：<strong>int</strong> 和 <strong>pair</strong> 。 下面是用枚举来标示一个对象的类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// pair : 任何一对东西</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</div><div class="line">    OBJ_INT,</div><div class="line">    OBJ_PAIR</div><div class="line">&#125; ObjectType;</div><div class="line"></div><div class="line"><span class="comment">// 因为一个对象在虚拟机中可以是这两个当中的任意一种类型，所以在C中用tagged union 来实现对象</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> sObject &#123;</div><div class="line">    <span class="comment">//表示对象类型：pair or int</span></div><div class="line">    ObjectType type;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> marked;</div><div class="line"></div><div class="line">    <span class="comment">//仅维持一张由所有分配过(内存)的对象(组成)的链表。</span></div><div class="line">    <span class="keyword">struct</span> sObject*next;</div><div class="line"></div><div class="line">    <span class="comment">//union持有这个数据</span></div><div class="line">    <span class="comment">//union就是一个结构体，它将字段重叠在内存中</span></div><div class="line">    <span class="keyword">union</span> &#123;</div><div class="line">        <span class="keyword">int</span> value;</div><div class="line"></div><div class="line">        <span class="keyword">struct</span> &#123;</div><div class="line">            <span class="keyword">struct</span> sObject* head;</div><div class="line">            <span class="keyword">struct</span> sObject* tail;</div><div class="line">        &#125;;</div><div class="line">    &#125;;</div><div class="line">&#125; Object;</div></pre></td></tr></table></figure>
<hr>
<h3 id="小虚拟机"><a href="#小虚拟机" class="headerlink" title="小虚拟机"></a>小虚拟机</h3><p>虚拟机要么基于栈( <strong>JVM</strong> , <strong>CLR</strong> )，要么基于寄存器( <strong>Lua</strong> )，其实本质上说都是基于栈的，它用来保存一个表达式中间需要用到的临时变量和局部变量</p>
<p>下面我们建立一个简洁的虚拟机模型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 小虚拟机</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">    Object* <span class="built_in">stack</span>[STACK_MAX];</div><div class="line">    <span class="keyword">int</span> stackSize;</div><div class="line"></div><div class="line">    <span class="comment">//虚拟机会保留链表头的痕迹</span></div><div class="line">    Object* firstObject;</div><div class="line"></div><div class="line">    <span class="comment">//追踪创建了多少个对象</span></div><div class="line">    <span class="keyword">int</span> numObjects;</div><div class="line"></div><div class="line">    <span class="comment">//多少数目之后清理</span></div><div class="line">    <span class="keyword">int</span> maxObjects;</div><div class="line">&#125; VM;</div></pre></td></tr></table></figure>
<hr>
<h3 id="虚拟机的操作"><a href="#虚拟机的操作" class="headerlink" title="虚拟机的操作"></a>虚拟机的操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 初始化一个虚拟机</span></div><div class="line"><span class="function">VM* <span class="title">newVM</span><span class="params">()</span> </span>&#123;</div><div class="line">    VM* vm = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(VM));</div><div class="line">    vm-&gt;stackSize = <span class="number">0</span>;</div><div class="line">    Object* firstObject = <span class="literal">NULL</span>;</div><div class="line">    vm-&gt;numObjects = <span class="number">0</span>;</div><div class="line">    vm-&gt;maxObjects = <span class="number">8</span>;</div><div class="line">    <span class="keyword">return</span> vm;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//操作虚拟机堆栈</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(VM* vm, Object* value)</span> </span>&#123;</div><div class="line">    assert(vm-&gt;stackSize &lt; STACK_MAX, <span class="string">"Stack overflow!!!"</span>);</div><div class="line">    vm-&gt;<span class="built_in">stack</span>[vm-&gt;stackSize++] = value;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">Object* <span class="title">pop</span><span class="params">(VM* vm)</span> </span>&#123;</div><div class="line">    assert(vm-&gt;stackSize &gt; <span class="number">0</span>, <span class="string">"Stack underflow!!!"</span>);</div><div class="line">    <span class="keyword">return</span> vm-&gt;<span class="built_in">stack</span>[--vm-&gt;stackSize];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="Mark"><a href="#Mark" class="headerlink" title="Mark"></a>Mark</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">mark</span><span class="params">(Object* object)</span> </span>&#123;</div><div class="line">    <span class="comment">//检查循环!</span></div><div class="line">    <span class="keyword">if</span> (object-&gt;marked) <span class="keyword">return</span>;</div><div class="line">    object-&gt;marked = <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (object-&gt;type == OBJ_PAIR) &#123;</div><div class="line">        mark(object-&gt;head);</div><div class="line">        mark(object-&gt;tail);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">markAll</span><span class="params">(VM* vm)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vm-&gt;stackSize; i++) &#123;</div><div class="line">        mark(vm-&gt;<span class="built_in">stack</span>[i]);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="Sweep"><a href="#Sweep" class="headerlink" title="Sweep"></a>Sweep</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//清理</span></div><div class="line"><span class="comment">//仅维持一张由所有分配过(内存)的对象(组成)的链表。</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sweep</span><span class="params">(VM* vm)</span> </span>&#123;</div><div class="line">    Object** object = &amp;vm-&gt;firstObject;</div><div class="line">    <span class="keyword">while</span> (*object) &#123;</div><div class="line">        <span class="keyword">if</span> (!(*object)-&gt;marked) &#123;</div><div class="line">            <span class="comment">//没有访问过，所以从链表中移除然后释放它</span></div><div class="line">            Object* unreached = *object;</div><div class="line"></div><div class="line">            *object = unreached-&gt;next;</div><div class="line">            <span class="built_in">free</span>(unreached);</div><div class="line"></div><div class="line">            vm-&gt;numObjects--;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//访问过，所以不标记它</span></div><div class="line">            (*object)-&gt;marked = <span class="number">0</span>;</div><div class="line">            object = &amp;(*object)-&gt;next;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">gc</span><span class="params">(VM* vm)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> numObjects = vm-&gt;numObjects;</div><div class="line"></div><div class="line">    markAll(vm);</div><div class="line">    sweep(vm);</div><div class="line"></div><div class="line">    vm-&gt;maxObjects = vm-&gt;numObjects * <span class="number">2</span>;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Collected %d objects, %d remaining.\n"</span>, numObjects - vm-&gt;numObjects,</div><div class="line">            vm-&gt;numObjects);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="对象操作函数"><a href="#对象操作函数" class="headerlink" title="对象操作函数"></a>对象操作函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="function">Object* <span class="title">newObject</span><span class="params">(VM* vm, ObjectType type)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (vm-&gt;numObjects == vm-&gt;maxObjects) gc(vm);</div><div class="line"></div><div class="line">    Object* object = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Object));</div><div class="line">    object-&gt;type = type;</div><div class="line">    <span class="comment">//无论何时创建对象，都添加到链表中</span></div><div class="line">    object-&gt;next = vm-&gt;firstObject;</div><div class="line">    vm-&gt;firstObject = object;</div><div class="line">    object-&gt;marked = <span class="number">0</span>;</div><div class="line"></div><div class="line">    vm-&gt;numObjects++;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> object;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//编写方法将每种类型的对象压到虚拟机的栈上</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushInt</span><span class="params">(VM* vm, <span class="keyword">int</span> intValue)</span> </span>&#123;</div><div class="line">    Object* object = newObject(vm, OBJ_INT);</div><div class="line">    object-&gt;value = intValue;</div><div class="line">    </div><div class="line">    push(vm, object);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">Object* <span class="title">pushPair</span><span class="params">(VM* vm)</span> </span>&#123;</div><div class="line">    Object* object = newObject(vm, OBJ_PAIR);</div><div class="line">    object-&gt;tail = pop(vm);</div><div class="line">    object-&gt;head = pop(vm);</div><div class="line"></div><div class="line">    push(vm, object);</div><div class="line">    <span class="keyword">return</span> object;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">objectPrint</span><span class="params">(Object* object)</span> </span>&#123;</div><div class="line">    <span class="keyword">switch</span> (object-&gt;type) &#123;</div><div class="line">        <span class="keyword">case</span> OBJ_INT:</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, object-&gt;value);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="keyword">case</span> OBJ_PAIR:</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"("</span>);</div><div class="line">        objectPrint(object-&gt;head);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">", "</span>);</div><div class="line">        objectPrint(object-&gt;tail);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">")"</span>);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="free、test、main"><a href="#free、test、main" class="headerlink" title="free、test、main"></a>free、test、main</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeVM</span><span class="params">(VM  *vm)</span> </span>&#123;</div><div class="line">    vm-&gt;stackSize = <span class="number">0</span>;</div><div class="line">    gc(vm);</div><div class="line">    <span class="built_in">free</span>(vm);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Test1: Objects on stack are preserved.\n"</span>);</div><div class="line">    VM* vm = newVM();</div><div class="line">    pushInt(vm, <span class="number">1</span>);</div><div class="line">    pushInt(vm, <span class="number">2</span>);</div><div class="line"></div><div class="line">    gc(vm);</div><div class="line">    assert(vm-&gt;numObjects == <span class="number">2</span>, <span class="string">"Should have preserved objects."</span>);</div><div class="line">    freeVM(vm);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Test2: Objects on stack are collected.\n"</span>);</div><div class="line">    VM* vm = newVM();</div><div class="line">    pushInt(vm, <span class="number">1</span>);</div><div class="line">    pushInt(vm, <span class="number">2</span>);</div><div class="line">    pop(vm);</div><div class="line">    pop(vm);</div><div class="line"></div><div class="line">    gc(vm);</div><div class="line">    assert(vm-&gt;numObjects == <span class="number">0</span>, <span class="string">"Should have collected objects."</span>);</div><div class="line">    freeVM(vm);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Test3: Reach nested objects.\n"</span>);</div><div class="line">    VM* vm = newVM();</div><div class="line">    pushInt(vm, <span class="number">1</span>);</div><div class="line">    pushInt(vm, <span class="number">2</span>);</div><div class="line">    pushPair(vm);</div><div class="line">    pushInt(vm, <span class="number">3</span>);</div><div class="line">    pushInt(vm, <span class="number">4</span>);</div><div class="line">    pushPair(vm);</div><div class="line">    pushPair(vm);</div><div class="line"></div><div class="line">    gc(vm);</div><div class="line">    assert(vm-&gt;numObjects == <span class="number">7</span>, <span class="string">"Should have reached objects."</span>);</div><div class="line">    freeVM(vm);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Test4: Handle cycles.\n"</span>);</div><div class="line">    VM* vm = newVM();</div><div class="line">    pushInt(vm, <span class="number">1</span>);</div><div class="line">    pushInt(vm, <span class="number">2</span>);</div><div class="line">    Object* a = pushPair(vm);</div><div class="line">    pushInt(vm, <span class="number">3</span>);</div><div class="line">    pushInt(vm, <span class="number">4</span>);</div><div class="line">    Object* b = pushPair(vm);</div><div class="line"></div><div class="line">    <span class="comment">//建立一个循环， 并且让2 和 4 不可到达和收集</span></div><div class="line">    a-&gt;tail = b;</div><div class="line">    b-&gt;tail = a;</div><div class="line"></div><div class="line">    gc(vm);</div><div class="line">    assert(vm-&gt;numObjects == <span class="number">4</span>, <span class="string">"Should have collected objects."</span>);</div><div class="line">    freeVM(vm);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">perfTest</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Performance Tset\n"</span>);</div><div class="line">    VM* vm = newVM();</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">20</span>; j++) &#123;</div><div class="line">            pushInt(vm, i);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">20</span>; k++) &#123;</div><div class="line">            pop(vm);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    freeVM(vm);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</div><div class="line">    test1();</div><div class="line">    test2();</div><div class="line">    test3();</div><div class="line">    test4();</div><div class="line">    perfTest();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><p><img src="http://oe9uinblw.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-14%2015.20.31.png" alt=""></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这个简单的收集器与目前 <strong>Ruby</strong> 和 <strong>Lua</strong> 中的收集器非常的相似，所以下一次我们将深入了解 <strong>Lua</strong> 的 <strong>GC</strong> 机制。</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/04/13/深入 Lua Garbage Collector(一)/" class="archive-article-date">
  	<time datetime="2017-04-13T01:54:34.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-04-13</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/gc/">gc</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/lua/">lua</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="airticle-Linux下的轻量服务器实现" class="article article-type-airticle" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/31/Linux下的轻量服务器实现/">Linux下的的轻量级HTTP服务器实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p></p><p></p>
<h2 id="小型HTTP服务器"><a href="#小型HTTP服务器" class="headerlink" title="小型HTTP服务器"></a>小型HTTP服务器</h2><p>读了很多 <strong>Linux</strong> 下小型的 <strong>http</strong> 服务器，还是觉得来自<a href="http://www.jianshu.com/p/912fa6d0b5e0" target="_blank" rel="external">朱家顺的Zaver</a>比较适合新手学习</p>
<blockquote>
<p>Zaver，一个结构简单，支持高并发的http服务器。基本架构是事件循环 + non-blocking I/O + 线程池。Zaver的代码风格参考了Nginx的风格，所以在可读性上非常高。另外，Zaver提供了配置文件和命令行参数解析，以及完善的Makefile和源代码结构，也可以帮助任何一个C初学者入门一个项目是怎么构建的。</p>
</blockquote>
<hr>
<h2 id="需要改进的地方"><a href="#需要改进的地方" class="headerlink" title="需要改进的地方"></a>需要改进的地方</h2><ul>
<li>只支持静态页面</li>
<li>HTTP1.1支持不完全，目前只实现了几个主要的（keep-alive, browser cache）的header解析</li>
<li>没有内存池</li>
<li>没有缓存</li>
<li>没有日志</li>
<li>没有用session建立对话</li>
<li>无活动连接的超时过期还没有做</li>
<li>后台运行用的是 <em>while死循环</em> 而不是 <em> daemon process </em> </li>
</ul>
<hr>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>主要还是体会一下，毕竟刚接触网络编程，顺便复习一下知识点</p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>使用一个文件描述符管理多个描述符，把事件都放入一个时间表中</p>
<ul>
<li>int epoll_create();</li>
<li>int epoll_ctl();</li>
<li>int epoll_wait();</li>
</ul>
<p>如果一个fd没有被它的工作线程读完，所以依然会被认为是可读的，如果下次事件循环又返回这个fd，又会分给别的线程。<br>所以要将默认的LT（level trigger）水平触发改为ET（edge trigger）边缘触发模式</p>
<p>更多关于select poll epoll的学习可以看<a href="http://www.cnblogs.com/Anker/p/3258674.html" target="_blank" rel="external">这个大神的博客</a></p>
<hr>
<h3 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h3><p>自定义调试信息的输出</p>
<blockquote>
<p>调试信息的输出方法有很多种,  例如直接用printf,  或者出错时使用perror, fprintf等将信息直接打印到终端上, 在Qt上面一般使用qDebug，而守护进程则一般是使用syslog将调试信息输出到日志文件中等等…</p>
<p>使用标准的方法打印调试信息有时候不是很方便,  例如Qt编程, 在调试已有的代码时, 我想在打印调试信息的地方, 把代码位置也打印出来以方便定位错误, 或者需要在调试信息前面加一个前辍, 好方便在调试信息太多的时候可以用grep过滤一下, 仅显示本模块的调试信息, 这时就需要一个一个地修改已有的qDebug, 使其成为以下形式:<br>　　<br>qDebug( “[模块名称] 调试信息  File:%s, Line:%d”, <strong>FILE</strong>, <strong>LINE</strong> );<br>　　<br>这样的修改比较烦人, 而且一不小心会遗漏某个没改的…<br>为了能方便地管理调试信息的输出，一个比较简单的方法就是自已定义一个打印调试信息的宏, 然后替换原来的，废话就不多说了，直接给出一个现成的，下面是一个例子, 我用WiFi表示当前代码的模块名称，我要求在模块中的所有调试信息前面均带有[WiFi]前辍，这样我就能方便地只需使用命令行 | grep “[WiFi]“来过滤掉来自其它模块的调试信息了:</p>
<p>#define qWiFiDebug(format, …) qDebug(“[WiFi] “format” File:%s, Line:%d, Function:%s”, ##<strong>VA_ARGS</strong>, <strong>FILE</strong>, <strong>LINE</strong> , <strong>FUNCTION</strong>);<br>　　<br>上面的宏是使用qDebug输出调试信息，在非Qt的程序中也可以改为printf，守护进程则可以改为syslog等等…  其中，决窍其实就是这几个宏 ##<strong>VA_ARGS</strong>, <strong>FILE</strong>, <strong>LINE</strong> 和<strong>FUNCTION</strong>,下面介绍一下这几个宏:<br>　　1)  <strong>VA_ARGS</strong> 是一个可变参数的宏，很少人知道这个宏，这个可变参数的宏是新的C99规范中新增的，目前似乎只有gcc支持（VC6.0的编译器不支持）。宏前面加上##的作用在于，当可变参数的个数为0时，这里的##起到把前面多余的”,”去掉的作用,否则会编译出错, 你可以试试。<br>　　2) <strong>FILE</strong> 宏在预编译时会替换成当前的源文件名<br>　　3) <strong>LINE</strong>宏在预编译时会替换成当前的行号<br>　　4) <strong>FUNCTION</strong>宏在预编译时会替换成当前的函数名称<br>　　有了以上这几个宏，特别是有了<strong>VA_ARGS</strong> ，调试信息的输出就变得灵活多了。</p>
</blockquote>
<hr>
<h3 id="threadpool"><a href="#threadpool" class="headerlink" title="threadpool"></a>threadpool</h3><p>用C++来实现线程池，之前也写过<a href="https://github.com/lizhenghn123/zl_threadpool" target="_blank" rel="external">这个大神的C++的线程池demo</a>，分别用C++98、C++03、C++11实现了一遍，体会到C++11的方便了啊</p>
<p>因为项目是C语言的，所以必须用到 <em> extern关键字 </em> 来混入C++代码，这也是面试常考的内容</p>
<p>具体的看这篇博文<a href="http://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777431.html" target="_blank" rel="external">C/C++中extern关键字详解</a></p>
<p>线程池主要含有三个队列</p>
<ul>
<li>工作队列</li>
<li>工作线程队列</li>
<li>忙碌线程队列</li>
</ul>
<hr>
<h3 id="timer"><a href="#timer" class="headerlink" title="timer"></a>timer</h3><p><strong>Nginx</strong> 用 <strong>rbtree</strong> 实现timer</p>
<p>但是为了简单化，我们用 <strong>libevent</strong> 的 <strong>2-heap</strong> 二叉最小堆来实现</p>
<blockquote>
<p>淘宝的 <strong>Tengine</strong> 用 <strong>4-heap</strong> 四叉最小堆实现 timer ，四叉最小堆是二叉最小堆的变种，比其有更浅的深度和更好的 <strong>CPU Cache</strong> 命中率</p>
</blockquote>
<h3 id="http"><a href="#http" class="headerlink" title="http"></a>http</h3><p>1.method</p>
<blockquote>
<p>nginx在判断http method的时候用的不是字符串比较，而是整数比较。<br>比如“POST”，一般的写法是用strcmp，就会牵扯到4次char的比较。<br>而nginx把接受到的method转化为一个int，那么4次比较就可以转化为1次比较。</p>
</blockquote>
<p>具体代码如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_str3Ocmp(m, c0, c1, c2, c3)                                     \</span></div><div class="line">    *(uint32_t *) m == ((c3 <span class="meta-string">&lt;&lt; 24) | (c2 &lt;&lt; 16) | (c1 &lt;&lt; 8) | c0)</span></div></pre></td></tr></table></figure>
<hr>
<p>2.request</p>
<ul>
<li>参考Nginx，用priority queue来存储header</li>
<li><a href="http://blog.csdn.net/stevenliyong/article/details/4160181" target="_blank" rel="external">关于__GNU_SOURCE这个宏</a></li>
<li><a href="http://stackoverflow.com/questions/20222079/epoll-wait-returning-events-on-closed-file-descriptor" target="_blank" rel="external">关于epoll的小细节</a></li>
</ul>
<p>3.parse</p>
<p>目前只实现了几个主要的（keep-alive, browser cache）的header解析</p>
<p>4.connection</p>
<p>这一部分的实现放在了utils里面</p>
<h3 id="utility各种通用函数"><a href="#utility各种通用函数" class="headerlink" title="utility各种通用函数"></a>utility各种通用函数</h3><p>这里主要是connect的函数</p>
<p>话说C的模块化真是一门技术活，全靠文件。。。</p>
<h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><h2 id="搭建成功"><a href="#搭建成功" class="headerlink" title="搭建成功"></a>搭建成功</h2><p><img src="http://oe9uinblw.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-09%2003.36.45.png" alt=""></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/03/31/Linux下的轻量服务器实现/" class="archive-article-date">
  	<time datetime="2017-03-31T03:53:23.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-03-31</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http/">http</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/">nginx</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/web-server/">web server</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="airticle-C++11 并发学习(四)" class="article article-type-airticle" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/15/C++11 并发学习(四)/">C++11 并发学习(四)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p></p><p><br><a href="http://www.cnblogs.com/haippy/p/3284540.html" target="_blank" rel="external">学习自大神博客</a></p>
<h2 id="下面我们来看一下C-11多线程下生产者消费者模型"><a href="#下面我们来看一下C-11多线程下生产者消费者模型" class="headerlink" title="下面我们来看一下C++11多线程下生产者消费者模型"></a>下面我们来看一下C++11多线程下生产者消费者模型</h2><h3 id="单生产者-单消费者模型"><a href="#单生产者-单消费者模型" class="headerlink" title="单生产者-单消费者模型"></a>单生产者-单消费者模型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kItemRepositorySize = <span class="number">10</span>;  <span class="comment">//Item buffer size</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kItemsToProduce = <span class="number">100</span>; <span class="comment">//How many items we plan to produce</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> ItemRepository &#123;</div><div class="line">    <span class="keyword">int</span> item_buffer[kItemRepositorySize]; <span class="comment">//产品缓冲区， 配合模拟环形队列</span></div><div class="line">    <span class="keyword">size_t</span> read_position; <span class="comment">//消费者读取产品位置</span></div><div class="line">    <span class="keyword">size_t</span> write_position; <span class="comment">//生产者写入产品位置</span></div><div class="line">    <span class="built_in">std</span>::mutex mtx; <span class="comment">//互斥量，保护产品缓冲区</span></div><div class="line">    <span class="built_in">std</span>::condition_variable repo_not_full; <span class="comment">//条件变量，指示产品缓冲区不为满</span></div><div class="line">    <span class="built_in">std</span>::condition_variable repo_not_empty; <span class="comment">//条件变量，指示产品缓冲区不为空</span></div><div class="line">&#125; gItemRepository; <span class="comment">//产品库全局变量，生产者和消费者操作该变量</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> ItemRepository ItemRepository;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProduceItem</span><span class="params">(ItemRepository *ir, <span class="keyword">int</span> item)</span> </span>&#123;</div><div class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(ir-&gt;mtx);</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (((ir-&gt;write_position + <span class="number">1</span>) % kItemRepositorySize) == ir-&gt;read_position) &#123;</div><div class="line">        <span class="comment">//buffer is full</span></div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Producer is waiting for an empty slot...\n"</span>;</div><div class="line">        (ir-&gt;repo_not_full).wait(lock); <span class="comment">//生产者等待"产品库缓冲区不为满"这一条件发生</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    (ir-&gt;item_buffer)[ir-&gt;write_position] = item; <span class="comment">//写入产品</span></div><div class="line">    (ir-&gt;write_position)++; <span class="comment">//写入位置后移</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (ir-&gt;write_position == kItemRepositorySize) &#123;</div><div class="line">        <span class="comment">//写入位置如果在队列最后 则需要重新设置为初始位置</span></div><div class="line">        ir-&gt;write_position = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    (ir-&gt;repo_not_empty).notify_all(); <span class="comment">//通知消费者产品库不为空</span></div><div class="line">    lock.unlock();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ConsumeItem</span><span class="params">(ItemRepository *ir)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> data;</div><div class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(ir-&gt;mtx);</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (ir-&gt;write_position == ir-&gt;read_position) &#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Consumer is waiting for items...\n"</span>;</div><div class="line">        (ir-&gt;repo_not_empty).wait(lock); <span class="comment">// 消费者等待"产品库缓冲区不为空"这一条件发生</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    data = (ir-&gt;item_buffer)[ir-&gt;read_position]; <span class="comment">//读取产品</span></div><div class="line">    (ir-&gt;read_position)++; <span class="comment">//读取位置后移</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (ir-&gt;read_position &gt;= kItemRepositorySize) &#123;</div><div class="line">        <span class="comment">//读取位置如果在队列最后 则需要重新设置为初始位置</span></div><div class="line">        ir-&gt;read_position = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    (ir-&gt;repo_not_full).notify_all();</div><div class="line">    lock.unlock();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> data;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//生产者任务</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProducerTask</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; kItemsToProduce; ++i) &#123;</div><div class="line">        <span class="comment">//sleep(1);</span></div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Produce the"</span> &lt;&lt; i &lt;&lt; <span class="string">"^th item..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">        ProduceItem(&amp;gItemRepository, i); <span class="comment">//循环生产 kItemsToProduce 个产品</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//消费者任务</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConsumerTask</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</div><div class="line">        sleep(<span class="number">1</span>);</div><div class="line">        <span class="keyword">int</span> item = ConsumeItem(&amp;gItemRepository); <span class="comment">//消费一个产品</span></div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Consume the"</span> &lt;&lt; item &lt;&lt; <span class="string">"^th item"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">        <span class="keyword">if</span> (++cnt == kItemsToProduce) &#123;</div><div class="line">            <span class="comment">//如果产品消费个数为 kItemsToProduce, 则退出.</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitItemRepository</span><span class="params">(ItemRepository *ir)</span> </span>&#123;</div><div class="line">    ir-&gt;write_position = <span class="number">0</span>;</div><div class="line">    ir-&gt;read_position = <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    InitItemRepository(&amp;gItemRepository);</div><div class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">producer</span><span class="params">(ProducerTask)</span></span>;</div><div class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">consumer</span><span class="params">(ConsumerTask)</span></span>;</div><div class="line">    producer.join();</div><div class="line">    consumer.join();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>运行结果：</p>
<p><img src="http://oe9uinblw.bkt.clouddn.com/C++%E5%B9%B6%E5%8F%911.png" alt=""></p>
<hr>
<h2 id="单生产者-多消费者模型"><a href="#单生产者-多消费者模型" class="headerlink" title="单生产者-多消费者模型"></a>单生产者-多消费者模型</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//与单生产者和单消费者模型不同的是，</span></div><div class="line"><span class="comment">//单生产者-多消费者模型中可以允许多个消费者同时从产品库中取走产品。</span></div><div class="line"><span class="comment">//所以除了保护产品库在多个读写线程下互斥之外，还需要维护消费者取走产品的计数器</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kItemRepositorySize = <span class="number">10</span>;  <span class="comment">//Item buffer size</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kItemsToProduce = <span class="number">100</span>; <span class="comment">//How many items we plan to produce</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> ItemRepository &#123;</div><div class="line">    <span class="keyword">int</span> item_buffer[kItemRepositorySize]; <span class="comment">//产品缓冲区， 配合模拟环形队列</span></div><div class="line">    <span class="keyword">size_t</span> read_position; <span class="comment">//消费者读取产品位置</span></div><div class="line">    <span class="keyword">size_t</span> write_position; <span class="comment">//生产者写入产品位置</span></div><div class="line">    </div><div class="line">    <span class="keyword">size_t</span> item_counter;</div><div class="line">    <span class="built_in">std</span>::mutex item_counter_mtx;</div><div class="line">    </div><div class="line">    <span class="built_in">std</span>::mutex mtx; <span class="comment">//互斥量，保护产品缓冲区</span></div><div class="line">    <span class="built_in">std</span>::condition_variable repo_not_full; <span class="comment">//条件变量，指示产品缓冲区不为满</span></div><div class="line">    <span class="built_in">std</span>::condition_variable repo_not_empty; <span class="comment">//条件变量，指示产品缓冲区不为空</span></div><div class="line">&#125; gItemRepository; <span class="comment">//产品库全局变量，生产者和消费者操作该变量</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> ItemRepository ItemRepository;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProduceItem</span><span class="params">(ItemRepository *ir, <span class="keyword">int</span> item)</span> </span>&#123;</div><div class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(ir-&gt;mtx);</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (((ir-&gt;write_position + <span class="number">1</span>) % kItemRepositorySize) == ir-&gt;read_position) &#123;</div><div class="line">        <span class="comment">//buffer is full</span></div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Producer is waiting for an empty slot...\n"</span>;</div><div class="line">        (ir-&gt;repo_not_full).wait(lock); <span class="comment">//生产者等待"产品库缓冲区不为满"这一条件发生</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    (ir-&gt;item_buffer)[ir-&gt;write_position] = item; <span class="comment">//写入产品</span></div><div class="line">    (ir-&gt;write_position)++; <span class="comment">//写入位置后移</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (ir-&gt;write_position == kItemRepositorySize) &#123;</div><div class="line">        <span class="comment">//写入位置如果在队列最后 则需要重新设置为初始位置</span></div><div class="line">        ir-&gt;write_position = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    (ir-&gt;repo_not_empty).notify_all(); <span class="comment">//通知消费者产品库不为空</span></div><div class="line">    lock.unlock();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ConsumeItem</span><span class="params">(ItemRepository *ir)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> data;</div><div class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(ir-&gt;mtx);</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (ir-&gt;write_position == ir-&gt;read_position) &#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Consumer is waiting for items...\n"</span>;</div><div class="line">        (ir-&gt;repo_not_empty).wait(lock); <span class="comment">// 消费者等待"产品库缓冲区不为空"这一条件发生</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    data = (ir-&gt;item_buffer)[ir-&gt;read_position]; <span class="comment">//读取产品</span></div><div class="line">    (ir-&gt;read_position)++; <span class="comment">//读取位置后移</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (ir-&gt;read_position &gt;= kItemRepositorySize) &#123;</div><div class="line">        <span class="comment">//读取位置如果在队列最后 则需要重新设置为初始位置</span></div><div class="line">        ir-&gt;read_position = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    (ir-&gt;repo_not_full).notify_all();</div><div class="line">    lock.unlock();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> data;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//生产者任务</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProducerTask</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; kItemsToProduce; ++i) &#123;</div><div class="line">        <span class="comment">//sleep(1);</span></div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Producer thread"</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">"Produce the"</span> &lt;&lt; i &lt;&lt; <span class="string">"^th item..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">        ProduceItem(&amp;gItemRepository, i); <span class="comment">//循环生产 kItemsToProduce 个产品</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Producer thread"</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">"is exiting..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//消费者任务</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConsumerTask</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">bool</span> ready_to_exit = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</div><div class="line">        sleep(<span class="number">1</span>);</div><div class="line">        <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(gItemRepository.item_counter_mtx);</div><div class="line">        <span class="keyword">if</span> (gItemRepository.item_counter &lt; kItemsToProduce) &#123;</div><div class="line">            <span class="keyword">int</span> item = ConsumeItem(&amp;gItemRepository);</div><div class="line">            ++(gItemRepository.item_counter);</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Consumer thread"</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">"is consuming the"</span> &lt;&lt; item &lt;&lt; <span class="string">"^th item"</span>&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">        &#125; <span class="keyword">else</span> ready_to_exit = <span class="literal">true</span>;</div><div class="line">        lock.unlock();</div><div class="line">        <span class="keyword">if</span> (ready_to_exit == <span class="literal">true</span>) &#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Consumer thread"</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">"is exiting..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitItemRepository</span><span class="params">(ItemRepository *ir)</span> </span>&#123;</div><div class="line">    ir-&gt;write_position = <span class="number">0</span>;</div><div class="line">    ir-&gt;read_position = <span class="number">0</span>;</div><div class="line">    ir-&gt;item_counter = <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    InitItemRepository(&amp;gItemRepository);</div><div class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">producer</span><span class="params">(ProducerTask)</span></span>;</div><div class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">consumer1</span><span class="params">(ConsumerTask)</span></span>;</div><div class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">consumer2</span><span class="params">(ConsumerTask)</span></span>;</div><div class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">consumer3</span><span class="params">(ConsumerTask)</span></span>;</div><div class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">consumer4</span><span class="params">(ConsumerTask)</span></span>;</div><div class="line">    producer.join();</div><div class="line">    consumer1.join();</div><div class="line">    consumer2.join();</div><div class="line">    consumer3.join();</div><div class="line">    consumer4.join();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>运行结果：</p>
<p><img src="http://oe9uinblw.bkt.clouddn.com/C++%E5%B9%B6%E5%8F%912.png" alt=""></p>
<hr>
<h2 id="多生产者-单消费者模型"><a href="#多生产者-单消费者模型" class="headerlink" title="多生产者-单消费者模型"></a>多生产者-单消费者模型</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//与单生产者和单消费者模型不同的是，</span></div><div class="line"><span class="comment">//单生产者-多消费者模型中可以允许多个消费者同时从产品库中取走产品。</span></div><div class="line"><span class="comment">//所以除了保护产品库在多个读写线程下互斥之外，还需要维护生产者放入产品的计数器</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kItemRepositorySize = <span class="number">10</span>;  <span class="comment">//Item buffer size</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kItemsToProduce = <span class="number">100</span>; <span class="comment">//How many items we plan to produce</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> ItemRepository &#123;</div><div class="line">    <span class="keyword">int</span> item_buffer[kItemRepositorySize]; <span class="comment">//产品缓冲区， 配合模拟环形队列</span></div><div class="line">    <span class="keyword">size_t</span> read_position; <span class="comment">//消费者读取产品位置</span></div><div class="line">    <span class="keyword">size_t</span> write_position; <span class="comment">//生产者写入产品位置</span></div><div class="line">    </div><div class="line">    <span class="keyword">size_t</span> item_counter;</div><div class="line">    <span class="built_in">std</span>::mutex item_counter_mtx;</div><div class="line">    </div><div class="line">    <span class="built_in">std</span>::mutex mtx; <span class="comment">//互斥量，保护产品缓冲区</span></div><div class="line">    <span class="built_in">std</span>::condition_variable repo_not_full; <span class="comment">//条件变量，指示产品缓冲区不为满</span></div><div class="line">    <span class="built_in">std</span>::condition_variable repo_not_empty; <span class="comment">//条件变量，指示产品缓冲区不为空</span></div><div class="line">&#125; gItemRepository; <span class="comment">//产品库全局变量，生产者和消费者操作该变量</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> ItemRepository ItemRepository;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProduceItem</span><span class="params">(ItemRepository *ir, <span class="keyword">int</span> item)</span> </span>&#123;</div><div class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(ir-&gt;mtx);</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (((ir-&gt;write_position + <span class="number">1</span>) % kItemRepositorySize) == ir-&gt;read_position) &#123;</div><div class="line">        <span class="comment">//buffer is full</span></div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Producer is waiting for an empty slot...\n"</span>;</div><div class="line">        (ir-&gt;repo_not_full).wait(lock); <span class="comment">//生产者等待"产品库缓冲区不为满"这一条件发生</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    (ir-&gt;item_buffer)[ir-&gt;write_position] = item; <span class="comment">//写入产品</span></div><div class="line">    (ir-&gt;write_position)++; <span class="comment">//写入位置后移</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (ir-&gt;write_position == kItemRepositorySize) &#123;</div><div class="line">        <span class="comment">//写入位置如果在队列最后 则需要重新设置为初始位置</span></div><div class="line">        ir-&gt;write_position = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    (ir-&gt;repo_not_empty).notify_all(); <span class="comment">//通知消费者产品库不为空</span></div><div class="line">    lock.unlock();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ConsumeItem</span><span class="params">(ItemRepository *ir)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> data;</div><div class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(ir-&gt;mtx);</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (ir-&gt;write_position == ir-&gt;read_position) &#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Consumer is waiting for items...\n"</span>;</div><div class="line">        (ir-&gt;repo_not_empty).wait(lock); <span class="comment">// 消费者等待"产品库缓冲区不为空"这一条件发生</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    data = (ir-&gt;item_buffer)[ir-&gt;read_position]; <span class="comment">//读取产品</span></div><div class="line">    (ir-&gt;read_position)++; <span class="comment">//读取位置后移</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (ir-&gt;read_position &gt;= kItemRepositorySize) &#123;</div><div class="line">        <span class="comment">//读取位置如果在队列最后 则需要重新设置为初始位置</span></div><div class="line">        ir-&gt;read_position = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    (ir-&gt;repo_not_full).notify_all();</div><div class="line">    lock.unlock();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> data;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//生产者任务</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProducerTask</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">bool</span> ready_to_exit = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">        sleep(<span class="number">1</span>);</div><div class="line">        <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(gItemRepository.item_counter_mtx);</div><div class="line">        <span class="keyword">if</span> (gItemRepository.item_counter &lt; kItemsToProduce) &#123;</div><div class="line">            ++(gItemRepository.item_counter);</div><div class="line">            ProduceItem(&amp;gItemRepository, gItemRepository.item_counter);</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Producer thread"</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">"is producing the"</span> &lt;&lt; gItemRepository.item_counter &lt;&lt; <span class="string">"^th item..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">        &#125; <span class="keyword">else</span> ready_to_exit = <span class="literal">true</span>;</div><div class="line">        lock.unlock();</div><div class="line">        <span class="keyword">if</span> (ready_to_exit == <span class="literal">true</span>) &#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Producer thread"</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">"is exiting..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//消费者任务</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConsumerTask</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> item_consumed = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">        sleep(<span class="number">1</span>);</div><div class="line">        ++item_consumed;</div><div class="line">        <span class="keyword">if</span> (item_consumed &lt;= kItemsToProduce) &#123;</div><div class="line">            <span class="keyword">int</span> item = ConsumeItem(&amp;gItemRepository);</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Consumer thread"</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">"is consuming the"</span> &lt;&lt; item &lt;&lt; <span class="string">"^th item"</span>&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;   </div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Consumer thread"</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">"is exiting..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitItemRepository</span><span class="params">(ItemRepository *ir)</span> </span>&#123;</div><div class="line">    ir-&gt;write_position = <span class="number">0</span>;</div><div class="line">    ir-&gt;read_position = <span class="number">0</span>;</div><div class="line">    ir-&gt;item_counter = <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    InitItemRepository(&amp;gItemRepository);</div><div class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">producer1</span><span class="params">(ProducerTask)</span></span>;</div><div class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">producer2</span><span class="params">(ProducerTask)</span></span>;</div><div class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">producer3</span><span class="params">(ProducerTask)</span></span>;</div><div class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">producer4</span><span class="params">(ProducerTask)</span></span>;</div><div class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">consumer</span><span class="params">(ConsumerTask)</span></span>;</div><div class="line">    producer1.join();</div><div class="line">    producer2.join();</div><div class="line">    producer3.join();</div><div class="line">    producer4.join();</div><div class="line">    consumer.join();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>运行结果：</p>
<p><img src="http://oe9uinblw.bkt.clouddn.com/C++%E5%B9%B6%E5%8F%913.png" alt=""></p>
<hr>
<h2 id="多生产者-多消费者模型"><a href="#多生产者-多消费者模型" class="headerlink" title="多生产者-多消费者模型"></a>多生产者-多消费者模型</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//该模型可以说是前面两种模型的综合，程序需要维护两个计数器，</span></div><div class="line"><span class="comment">//分别是生产者已生产产品的数目和消费者已取走产品的数目。</span></div><div class="line"><span class="comment">//另外也需要保护产品库在多个生产者和多个消费者互斥地访问</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kItemRepositorySize = <span class="number">10</span>;  <span class="comment">//Item buffer size</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kItemsToProduce = <span class="number">100</span>; <span class="comment">//How many items we plan to produce</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> ItemRepository &#123;</div><div class="line">    <span class="keyword">int</span> item_buffer[kItemRepositorySize]; <span class="comment">//产品缓冲区， 配合模拟环形队列</span></div><div class="line">    <span class="keyword">size_t</span> read_position; <span class="comment">//消费者读取产品位置</span></div><div class="line">    <span class="keyword">size_t</span> write_position; <span class="comment">//生产者写入产品位置</span></div><div class="line">    </div><div class="line">    <span class="keyword">size_t</span> produced_item_counter;</div><div class="line">    <span class="keyword">size_t</span> consumed_item_counter;</div><div class="line"></div><div class="line">    <span class="built_in">std</span>::mutex produced_item_counter_mtx;</div><div class="line">    <span class="built_in">std</span>::mutex consumed_item_counter_mtx;</div><div class="line">    </div><div class="line">    <span class="built_in">std</span>::mutex mtx; <span class="comment">//互斥量，保护产品缓冲区</span></div><div class="line">    <span class="built_in">std</span>::condition_variable repo_not_full; <span class="comment">//条件变量，指示产品缓冲区不为满</span></div><div class="line">    <span class="built_in">std</span>::condition_variable repo_not_empty; <span class="comment">//条件变量，指示产品缓冲区不为空</span></div><div class="line">&#125; gItemRepository; <span class="comment">//产品库全局变量，生产者和消费者操作该变量</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> ItemRepository ItemRepository;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProduceItem</span><span class="params">(ItemRepository *ir, <span class="keyword">int</span> item)</span> </span>&#123;</div><div class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(ir-&gt;mtx);</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (((ir-&gt;write_position + <span class="number">1</span>) % kItemRepositorySize) == ir-&gt;read_position) &#123;</div><div class="line">        <span class="comment">//buffer is full</span></div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Producer is waiting for an empty slot...\n"</span>;</div><div class="line">        (ir-&gt;repo_not_full).wait(lock); <span class="comment">//生产者等待"产品库缓冲区不为满"这一条件发生</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    (ir-&gt;item_buffer)[ir-&gt;write_position] = item; <span class="comment">//写入产品</span></div><div class="line">    (ir-&gt;write_position)++; <span class="comment">//写入位置后移</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (ir-&gt;write_position == kItemRepositorySize) &#123;</div><div class="line">        <span class="comment">//写入位置如果在队列最后 则需要重新设置为初始位置</span></div><div class="line">        ir-&gt;write_position = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    (ir-&gt;repo_not_empty).notify_all(); <span class="comment">//通知消费者产品库不为空</span></div><div class="line">    lock.unlock();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ConsumeItem</span><span class="params">(ItemRepository *ir)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> data;</div><div class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(ir-&gt;mtx);</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (ir-&gt;write_position == ir-&gt;read_position) &#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Consumer is waiting for items...\n"</span>;</div><div class="line">        (ir-&gt;repo_not_empty).wait(lock); <span class="comment">// 消费者等待"产品库缓冲区不为空"这一条件发生</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    data = (ir-&gt;item_buffer)[ir-&gt;read_position]; <span class="comment">//读取产品</span></div><div class="line">    (ir-&gt;read_position)++; <span class="comment">//读取位置后移</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (ir-&gt;read_position &gt;= kItemRepositorySize) &#123;</div><div class="line">        <span class="comment">//读取位置如果在队列最后 则需要重新设置为初始位置</span></div><div class="line">        ir-&gt;read_position = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    (ir-&gt;repo_not_full).notify_all();</div><div class="line">    lock.unlock();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> data;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//生产者任务</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProducerTask</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">bool</span> ready_to_exit = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">        sleep(<span class="number">1</span>);</div><div class="line">        <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(gItemRepository.produced_item_counter_mtx);</div><div class="line">        <span class="keyword">if</span> (gItemRepository.produced_item_counter &lt; kItemsToProduce) &#123;</div><div class="line">            ++(gItemRepository.produced_item_counter);</div><div class="line">            ProduceItem(&amp;gItemRepository, gItemRepository.produced_item_counter);</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Producer thread"</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">"is producing the"</span> &lt;&lt; gItemRepository.produced_item_counter &lt;&lt; <span class="string">"^th item..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">        &#125; <span class="keyword">else</span> ready_to_exit = <span class="literal">true</span>;</div><div class="line">        lock.unlock();</div><div class="line">        <span class="keyword">if</span> (ready_to_exit == <span class="literal">true</span>) &#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Producer thread"</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">"is exiting..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//消费者任务</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConsumerTask</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">bool</span> ready_to_exit = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">        sleep(<span class="number">1</span>);</div><div class="line">        <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(gItemRepository.consumed_item_counter_mtx);</div><div class="line">        <span class="keyword">if</span> (gItemRepository.consumed_item_counter &lt;= kItemsToProduce) &#123;</div><div class="line">            <span class="keyword">int</span> item = ConsumeItem(&amp;gItemRepository);</div><div class="line">            ++(gItemRepository.consumed_item_counter);</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Consumer thread"</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">"is consuming the"</span> &lt;&lt; gItemRepository.consumed_item_counter &lt;&lt; <span class="string">"^th item"</span>&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  </div><div class="line">        &#125; <span class="keyword">else</span> ready_to_exit = <span class="literal">true</span>;</div><div class="line">        lock.unlock();</div><div class="line">        <span class="keyword">if</span> (ready_to_exit == <span class="literal">true</span>) &#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Consumer thread"</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">"is exiting..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitItemRepository</span><span class="params">(ItemRepository *ir)</span> </span>&#123;</div><div class="line">    ir-&gt;write_position = <span class="number">0</span>;</div><div class="line">    ir-&gt;read_position = <span class="number">0</span>;</div><div class="line">    ir-&gt;produced_item_counter = <span class="number">0</span>;</div><div class="line">    ir-&gt;consumed_item_counter = <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    InitItemRepository(&amp;gItemRepository);</div><div class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">producer1</span><span class="params">(ProducerTask)</span></span>;</div><div class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">producer2</span><span class="params">(ProducerTask)</span></span>;</div><div class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">producer3</span><span class="params">(ProducerTask)</span></span>;</div><div class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">producer4</span><span class="params">(ProducerTask)</span></span>;</div><div class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">consumer1</span><span class="params">(ConsumerTask)</span></span>;</div><div class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">consumer2</span><span class="params">(ConsumerTask)</span></span>;</div><div class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">consumer3</span><span class="params">(ConsumerTask)</span></span>;</div><div class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">consumer4</span><span class="params">(ConsumerTask)</span></span>;</div><div class="line">    producer1.join();</div><div class="line">    producer2.join();</div><div class="line">    producer3.join();</div><div class="line">    producer4.join();</div><div class="line">    consumer1.join();</div><div class="line">    consumer2.join();</div><div class="line">    consumer3.join();</div><div class="line">    consumer4.join();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>运行结果：</p>
<p><img src="http://oe9uinblw.bkt.clouddn.com/C++%E5%B9%B6%E5%8F%914.png" alt=""></p>
<hr>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/02/15/C++11 并发学习(四)/" class="archive-article-date">
  	<time datetime="2017-02-15T06:52:04.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-02-15</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/concurrency/">concurrency</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/threadpool/">threadpool</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="airticle-C++11 并发学习(三)" class="article article-type-airticle" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/14/C++11 并发学习(三)/">C++11 并发学习(三)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p></p><p><br><a href="http://www.cnblogs.com/haippy/p/3284540.html" target="_blank" rel="external">学习自大神博客</a></p>
<h2 id="C-11-ThreadPool-简单实现"><a href="#C-11-ThreadPool-简单实现" class="headerlink" title="C++11 ThreadPool 简单实现"></a>C++11 ThreadPool 简单实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> THREAD_POOL_H</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_POOL_H</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">// C++11 版的 线程池</span></div><div class="line"><span class="keyword">namespace</span> zl</div><div class="line">&#123;</div><div class="line">    <span class="keyword">class</span> ThreadsGuard</div><div class="line">    &#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        ThreadsGuard(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt;&amp; v)</div><div class="line">            : threads_(v)</div><div class="line">        &#123;</div><div class="line">            </div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ~ThreadsGuard()</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != threads_.size(); ++i)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span> (threads_[i].joinable())</div><div class="line">                &#123;</div><div class="line">                    threads_[i].join();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        ThreadsGuard(ThreadsGuard&amp;&amp; tg) = <span class="keyword">delete</span>;</div><div class="line">        ThreadsGuard&amp; <span class="keyword">operator</span> = (ThreadsGuard&amp;&amp; tg) = <span class="keyword">delete</span>;</div><div class="line"></div><div class="line">        ThreadsGuard(<span class="keyword">const</span> ThreadsGuard&amp;) = <span class="keyword">delete</span>;</div><div class="line">        ThreadsGuard&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> ThreadsGuard&amp;) = <span class="keyword">delete</span>;</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt;&amp; threads_;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">class</span> ThreadPool</div><div class="line">    &#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="keyword">typedef</span> <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; task_type;</div><div class="line"></div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">ThreadPool</span><span class="params">(<span class="keyword">int</span> n = <span class="number">0</span>)</span></span>;</div><div class="line"></div><div class="line">        ~ThreadPool()</div><div class="line">        &#123;</div><div class="line">            stop();</div><div class="line">            cond_.notify_all();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span></div><div class="line">        &#123;</div><div class="line">            stop_.store(<span class="literal">true</span>, <span class="built_in">std</span>::memory_order_release);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">template</span>&lt;<span class="keyword">class</span> Function, <span class="keyword">class</span>... Args&gt;</div><div class="line">        <span class="built_in">std</span>::future&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::result_of&lt;Function(Args...)&gt;::type&gt; add(Function&amp;&amp;, Args&amp;&amp;...);</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        ThreadPool(ThreadPool&amp;&amp;) = <span class="keyword">delete</span>;</div><div class="line">        ThreadPool&amp; <span class="keyword">operator</span> = (ThreadPool&amp;&amp;) = <span class="keyword">delete</span>;</div><div class="line">        ThreadPool(<span class="keyword">const</span> ThreadPool&amp;) = <span class="keyword">delete</span>;</div><div class="line">        ThreadPool&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> ThreadPool&amp;) = <span class="keyword">delete</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        <span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; stop_;</div><div class="line">        <span class="built_in">std</span>::mutex mtx_;</div><div class="line">        <span class="built_in">std</span>::condition_variable cond_;</div><div class="line"></div><div class="line">        <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;task_type&gt; tasks_;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; threads_;</div><div class="line">        zl::ThreadsGuard tg_;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">inline</span> ThreadPool::ThreadPool(<span class="keyword">int</span> n)</div><div class="line">        : stop_(<span class="literal">false</span>)</div><div class="line">        , tg_(threads_)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> nthreads = n;</div><div class="line">        <span class="keyword">if</span> (nthreads &lt;= <span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">            nthreads = <span class="built_in">std</span>::thread::hardware_concurrency();</div><div class="line">            nthreads = (nthreads == <span class="number">0</span> ? <span class="number">2</span> : nthreads);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != nthreads; ++i)</div><div class="line">        &#123;</div><div class="line">            threads_.push_back(<span class="built_in">std</span>::thread([<span class="keyword">this</span>]&#123;</div><div class="line">                <span class="keyword">while</span> (!stop_.load(<span class="built_in">std</span>::memory_order_acquire))</div><div class="line">                &#123;</div><div class="line">                    task_type task;</div><div class="line">                    &#123;</div><div class="line">                        <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; ulk(<span class="keyword">this</span>-&gt;mtx_);</div><div class="line">                        <span class="keyword">this</span>-&gt;cond_.wait(ulk, [<span class="keyword">this</span>]&#123; <span class="keyword">return</span> stop_.load(<span class="built_in">std</span>::memory_order_acquire) || !<span class="keyword">this</span>-&gt;tasks_.empty(); &#125;);</div><div class="line">                        <span class="keyword">if</span> (stop_.load(<span class="built_in">std</span>::memory_order_acquire))</div><div class="line">                            <span class="keyword">return</span>;</div><div class="line">                        task = <span class="built_in">std</span>::move(<span class="keyword">this</span>-&gt;tasks_.front());</div><div class="line">                        <span class="keyword">this</span>-&gt;tasks_.pop();</div><div class="line">                    &#125;</div><div class="line">                    task();</div><div class="line">                &#125;</div><div class="line">            &#125;));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> Function, <span class="keyword">class</span>... Args&gt;</div><div class="line">    <span class="built_in">std</span>::future&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::result_of&lt;Function(Args...)&gt;::type&gt;</div><div class="line">        ThreadPool::add(Function&amp;&amp; fcn, Args&amp;&amp;... args)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="built_in">std</span>::result_of&lt;Function(Args...)&gt;::type return_type;</div><div class="line">        <span class="keyword">typedef</span> <span class="built_in">std</span>::packaged_task&lt;return_type()&gt; task;</div><div class="line"></div><div class="line">        <span class="keyword">auto</span> t = <span class="built_in">std</span>::make_shared&lt;task&gt;(<span class="built_in">std</span>::bind(<span class="built_in">std</span>::forward&lt;Function&gt;(fcn), <span class="built_in">std</span>::forward&lt;Args&gt;(args)...));</div><div class="line">        <span class="keyword">auto</span> ret = t-&gt;get_future();</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lg(mtx_);</div><div class="line">            <span class="keyword">if</span> (stop_.load(<span class="built_in">std</span>::memory_order_acquire))</div><div class="line">                <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"thread pool has stopped"</span>);</div><div class="line">            tasks_.emplace([t]&#123;(*t)(); &#125;);</div><div class="line">        &#125;</div><div class="line">        cond_.notify_one();</div><div class="line">        <span class="keyword">return</span> ret;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">/* THREAD_POOL_H */</span></span></div></pre></td></tr></table></figure>
<hr>
<h2 id="线程池的具体思路就不多说了，我们主要说一下用到的-c-11-的部分"><a href="#线程池的具体思路就不多说了，我们主要说一下用到的-c-11-的部分" class="headerlink" title="线程池的具体思路就不多说了，我们主要说一下用到的 c++11 的部分"></a>线程池的具体思路就不多说了，我们主要说一下用到的 <strong>c++11</strong> 的部分</h2><h3 id="首先是建立了一个-std-vector-lt-std-thread-gt-amp-v-的容器"><a href="#首先是建立了一个-std-vector-lt-std-thread-gt-amp-v-的容器" class="headerlink" title="首先是建立了一个 std::vector&lt; std::thread&gt;&amp; v 的容器"></a>首先是建立了一个 std::vector&lt; std::thread&gt;&amp; v 的容器</h3><h3 id="定义了一个原子操作-std-atomic-lt-bool-gt-stop-对bool进行了原子性封装"><a href="#定义了一个原子操作-std-atomic-lt-bool-gt-stop-对bool进行了原子性封装" class="headerlink" title="定义了一个原子操作 std::atomic&lt; bool&gt; stop_  对bool进行了原子性封装"></a>定义了一个原子操作 std::atomic&lt; bool&gt; stop_  对bool进行了原子性封装</h3><h3 id="然后不仅用到了-std-lock-guard，还用了相比其提供了更好的上锁和解锁控制的-std-unique-lock。"><a href="#然后不仅用到了-std-lock-guard，还用了相比其提供了更好的上锁和解锁控制的-std-unique-lock。" class="headerlink" title="然后不仅用到了 std::lock_guard，还用了相比其提供了更好的上锁和解锁控制的 std::unique_lock。"></a>然后不仅用到了 std::lock_guard，还用了相比其提供了更好的上锁和解锁控制的 std::unique_lock。</h3><p>这里主要介绍一下操作更为丰富的 <strong>std::unique_lock</strong></p>
<blockquote>
<p>顾名思义，<strong>unique_lock</strong> 对象以独占所有权的方式（unique owership）管理 <strong>mutex</strong> 对象的上锁和解锁操作，所谓独占所有权，就是没有其他的 <strong>unique_lock</strong> 对象同时拥有某个 <strong>mutex</strong> 对象的所有权。</p>
</blockquote>
<p>  ①. 上锁/解锁操作：lock，try_lock，try_lock_for，try_lock_until 和 unlock</p>
<p>  ②. 修改操作：移动赋值(move assignment)(前面已经介绍过了)，交换(swap)（与另一个 std::unique_lock 对象交换它们所管理的 Mutex 对象的所有权），释放(release)（返回指向它所管理的 Mutex 对象的指针，并释放所有权）</p>
<p>  ③. 获取属性操作：owns_lock（返回当前 std::unique_lock 对象是否获得了锁）、operator bool()（与 owns_lock 功能相同，返回当前 std::unique_lock 对象是否获得了锁）、mutex（返回当前 std::unique_lock 对象所管理的 Mutex 对象的指针）。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><blockquote>
<p>感觉这个例子还是用到挺多 <strong>C++11</strong> 的特性，在这里还是得一一解释一下（只是简单解释一下，关于C++还有很多要学的，我目前也只是个菜鸡啊。。。 <strong>C++</strong> 太棒了！特性多到你学不完→→手动滑稽）：</p>
</blockquote>
<h3 id="首先是std-function"><a href="#首先是std-function" class="headerlink" title="首先是std::function"></a>首先是std::function</h3><p>简单的来说就是：</p>
<blockquote>
<p>通过std::function对 <strong>C++</strong> 中各种可调用实体（普通函数、Lambda表达式、函数指针、以及其它函数对象等）的封装，形成一个新的可调用的std::function对象；让我们不再纠结那么多的可调用实体。一切变的简单粗暴。</p>
</blockquote>
<p>其实就是以前我们用函数指针来统一处理不同的函数对象类型，现在我们可以使用更安全的std::function来完成这些任务。</p>
<p>在上述例子中，使用它来定义了一个任务类型对象</p>
<p>typedef std::function&lt; void()&gt; task_type;</p>
<p><a href="http://www.jellythink.com/archives/771" target="_blank" rel="external">更为深入地学习，可以看这篇博客</a></p>
<h3 id="std-memory-order"><a href="#std-memory-order" class="headerlink" title="std::memory_order"></a>std::memory_order</h3><p>C++11 中规定了6种访存次序(Memory Order)，<a href="https://www.zhihu.com/question/24301047" target="_blank" rel="external">知乎上给出了通俗的解释</a></p>
<ul>
<li>momory_order_relaxed,</li>
<li>memory_order_consume,</li>
<li>memory_order_acquire,</li>
<li>memory_order_release,</li>
<li>memory_order_acq_rel,</li>
<li>memory_order_seq_cst.</li>
</ul>
<blockquote>
<p>虽然有6个选项，其实表示的是三种内存模型</p>
</blockquote>
<ul>
<li><p>sequential consistent(memory_order_seq_cst)</p>
</li>
<li><p>relaxed(memory_order_seq_cst)</p>
</li>
<li><p>acquire release(memory_order_consume, memory_order_acquire, memory_order_release, memory_order_acq_rel) </p>
</li>
</ul>
<p>我们这里用到的是获取-释放次序 <em>acquire release</em></p>
<blockquote>
<p>目的就是限制两个来自不同线程的原子操作的顺序，具体的操作就是需要两个线程进行一下同步，同步对一个变量的读写操作…</p>
</blockquote>
<p>①. 原子 <strong>load</strong> 操作：</p>
<p>while (!stop_.load(std::memory_order_acquire))</p>
<p>②. 原子 <strong>store</strong> 操作：</p>
<p>std::memory_order_release</p>
<h3 id="std-result-of"><a href="#std-result-of" class="headerlink" title="std::result_of"></a>std::result_of</h3><p>其实这个就是和我们之前的auto decltype都是属于自动类型推导，主要是使我们的代码可读易维护</p>
<p>我们这里用的<br>std::future&lt; typename std::result_of&lt; Function(Args…)&gt;::type&gt; add(Function&amp;&amp;, Args&amp;&amp;…);<br>就是为了获取function的返回值</p>
<blockquote>
<p>result_of 其实就是通过decltype来推导函数的返回类型</p>
</blockquote>
<h3 id="std-move"><a href="#std-move" class="headerlink" title="std::move"></a>std::move</h3><p>在C++11中，标准库在&lt; utility&gt;中提供了一个有用的函数std::move，这个函数的名字具有迷惑性，因为实际上std::move并不能移动任何东西，它唯一的功能是将一个左值强制转化为右值引用，继而我们可以通过右值引用使用该值，以用于移动语义。从实现上讲，std::move基本等同于一个类型转换：<br>static_cast&lt; T&amp;&amp;&gt;(lvalue);</p>
<blockquote>
<p>值得一提的是，被转化的左值，其生命期并没有随着左右值的转化而改变。如果读者期望std::move转化的左值变量lvalue能立即被析构，那么肯定会失望了。</p>
</blockquote>
<h3 id="std-packaged-task"><a href="#std-packaged-task" class="headerlink" title="std::packaged_task"></a>std::packaged_task</h3><p>std::packaged_task它包装了一个可调用的目标（如function, lambda expression, bind expression, or another function object）,以便异步调用，它和promise在某种程度上有点像，promise保存了一个共享状态的值，而packaged_task保存的是一个函数</p>
<p>typedef std::packaged_task&lt; return_type()&gt; task;</p>
<h3 id="std-make-shared"><a href="#std-make-shared" class="headerlink" title="std::make_shared"></a>std::make_shared</h3><p>C++11 中引入了智能指针, 同时还有一个模板函数 std::make_shared 可以返回一个指定类型的 std::shared_ptr：</p>
<p>struct A;<br>std::shared_ptr&lt; A&gt; p1 = std::make_shared&lt; A&gt;();<br>std::shared_ptr&lt; A&gt; p2(new A);</p>
<p>①. 如果是使用 <strong>new</strong> ：</p>
<p>auto p = new widget();<br>shared_ptr sp1{ p }, sp2{ sp1 };<br>需要两次内存分配</p>
<p>②. 然而使用 <strong>make_shared</strong> 的话：</p>
<p>auto sp1 = make_shared(), sp2{ sp1 };</p>
<p>所以我们这里 <strong>std::make_shared</strong> 其实就是为了代替 <strong>new</strong><br>auto t = std::make_shared&lt; task&gt;(std::bind(std::forward&lt; Function&gt;(fcn), std::forward&lt; Args&gt;(args)…));</p>
<p><a href="http://www.tuicool.com/articles/F3u6jy" target="_blank" rel="external">想要进一步了解它与std::shared_ptr的构造函数比较的戳</a></p>
<p>总结一些我们需要了解的就是：</p>
<p>①. 同直接使用new相比，make函数减小了代码重复，提高的异常安全，并且对于std::make_shared和std::allcoated_shared，生成的代码会更小更快。</p>
<p>②. 不能使用make函数的情况包括我们需要定制删除器和期望直接传递大括号初始化器。</p>
<p>③. 对于std::shared_ptr，额外的不建议使用make函数的情况包括：<br>（1）定制内存管理的类<br>（2）关注内存的系统，非常大的对象，以及生存期比 std::shared_ptr长的std::weak_ptr</p>
<p>下一篇我们将会实现C++11多线程下各种生产者消费者模型</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/02/14/C++11 并发学习(三)/" class="archive-article-date">
  	<time datetime="2017-02-14T04:02:34.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-02-14</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/concurrency/">concurrency</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/threadpool/">threadpool</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="airticle-C++11 并发学习(二)" class="article article-type-airticle" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/14/C++11 并发学习(二)/">C++11 并发学习(二)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p></p><p><br><a href="http://www.cnblogs.com/haippy/p/3284540.html" target="_blank" rel="external">学习自大神博客</a></p>
<h2 id="线程详解"><a href="#线程详解" class="headerlink" title="线程详解"></a>线程详解</h2><p>具体源码的大家有兴趣的可以去查看<a href="http://www.open-std.org/" target="_blank" rel="external">c++ 标准委员会的官方文档</a></p>
<p>在这里我主要讲一下他们的主要结构以及主要用法</p>
<h3 id="lt-thread-gt"><a href="#lt-thread-gt" class="headerlink" title="&lt; thread&gt;"></a>&lt; thread&gt;</h3><ol>
<li>std::thread 简单例子</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span> <span class="comment">// std::cout</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span>   <span class="comment">// std::thread</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_task</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello thread"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t</span><span class="params">(thread_task)</span></span>;</div><div class="line">    t.join();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="lt-mutex-gt"><a href="#lt-mutex-gt" class="headerlink" title="&lt; mutex&gt;"></a>&lt; mutex&gt;</h3><blockquote>
<p>std::mutex 是C++11 中最基本的互斥量，std::mutex 对象提供了独占所有权的特性——即不支持递归地对 std::mutex 对象上锁，而 std::recursive_lock 则可以递归地对互斥量对象上锁。</p>
</blockquote>
<p>①. <strong>Mutex</strong> 系列类(四种)</p>
<ul>
<li>std::mutex，最基本的 Mutex 类。</li>
<li>std::recursive_mutex，递归 Mutex 类。</li>
<li>std::time_mutex，定时 Mutex 类。</li>
<li>std::recursive_timed_mutex，定时递归 Mutex 类</li>
</ul>
<p>②. <strong>Lock</strong> 类（两种）</p>
<ul>
<li>std::lock_guard，与 Mutex RAII （资源获取即初始化）相关，方便线程对互斥量上锁。</li>
<li>std::unique_lock，与 Mutex RAII （资源获取即初始化）相关，方便线程对互斥量上锁，但提供了更好的上锁和解锁控制。</li>
</ul>
<h3 id="lt-condition-variable-gt"><a href="#lt-condition-variable-gt" class="headerlink" title="&lt; condition_variable&gt;"></a>&lt; condition_variable&gt;</h3><blockquote>
<p>&lt; condition_variable &gt; 头文件主要包含了与条件变量相关的类和函数。与条件变量相关的类包括 std::condition_variable 和 std::condition_variable_any，还有枚举类型std::cv_status。另外还包括函数 std::notify_all_at_thread_exit()</p>
<p>在 <strong>Linux</strong> 下是使用 <strong>Pthread</strong> 库中的 <strong>pthread<em>cond</em>*() </strong> 函数来实现条件变量相关的功能</p>
</blockquote>
<h3 id="lt-future-gt"><a href="#lt-future-gt" class="headerlink" title="&lt; future&gt;"></a>&lt; future&gt;</h3><blockquote>
<p>C++11 标准中与异步任务系相关的类型主要是以下四种 std::promise，std::packaged_task（std::promise，std::packaged_task 也称为异步任务的提供者 Provider，此外 std::async 也可以作为异步任务的提供者，不过 std::async 并不是类，而是函数，本章后面会详细介绍异步任务的提供者 Provider），std::future，std::shared_future。另外 &lt; future&gt; 中还定义一些辅助的类，例如： std::future_error，std::future_errc，std::status，std::launch。</p>
</blockquote>
<p>之前也有提到，主要是用来实现异步</p>
<h3 id="lt-atomic-gt"><a href="#lt-atomic-gt" class="headerlink" title="&lt; atomic&gt;"></a>&lt; atomic&gt;</h3><p>关于C++11的原子操作之前我有过笔记，下图</p>
<p><img src="http://oe9uinblw.bkt.clouddn.com/WechatIMG2.jpeg" alt=""></p>
<p>好了，关于 <strong>C++11</strong> 的新特性大致的梳理了一遍，接下来我们先看看之前提到的那个 <strong>C++11</strong> 的线程池具体是怎么实现的吧</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/02/14/C++11 并发学习(二)/" class="archive-article-date">
  	<time datetime="2017-02-13T17:02:34.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-02-14</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/concurrency/">concurrency</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/thread/">thread</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="airticle-C++11 并发学习(一)" class="article article-type-airticle" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/13/C++11 并发学习(一)/">C++11 并发学习(一)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p></p><p><br><a href="http://www.cnblogs.com/haippy/p/3284540.html" target="_blank" rel="external">学习自大神博客</a></p>
<h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2><blockquote>
<p>与并发相近的另一个概念是并行(Parallel)。和并发所描述的情况一样，并行也是指两个或多个任务被同时执行。但是严格来讲，并发和并行的概念并是不等同的，两者存在很大的差别。下面我们来看看计算机科学家们是怎么区分并发和并行的。</p>
<p>并发是一个处理器同时处理多个任务，而并行是多个处理器或者是多核的处理器同时处理多个不同的任务。前者是逻辑上的同时发生（simultaneous），而后者是物理上的同时发生。</p>
</blockquote>
<h2 id="C-并发"><a href="#C-并发" class="headerlink" title="C++并发"></a>C++并发</h2><h3 id="C-11多线程相关的头文件"><a href="#C-11多线程相关的头文件" class="headerlink" title="C++11多线程相关的头文件"></a>C++11多线程相关的头文件</h3><blockquote>
<p>C++11 新标准中引入了五个头文件来支持多线程编程，它们分别是 &lt; atomic&gt;, &lt; thread&gt;, &lt; mutex&gt;, &lt; condition_variable&gt; 和 &lt; future&gt;。</p>
</blockquote>
<p>①. &lt; atomic&gt;：该头文主要声明了两个类, std::atomic 和 std::atomic_flag，另外还声明了一套 C 风格的原子类型和与 C 兼容的原子操作的函数。<br>&lt; atomic&gt; 一一 可以用来实现数据结构的无锁结构</p>
<p>②. &lt; thread&gt;：该头文件主要声明了 std::thread 类，另外 std::this_thread 命名空间也在该头文件中。<br>之前在Linux下写多线程的时候用的Pthread，但是在实现线程池的时候，有用到过C++11的<thread>，具体是学习自<a href="https://github.com/lizhenghn123/zl_threadpool" target="_blank" rel="external">这个大神的C++的线程池demo</a></thread></p>
<p>③. &lt; mutex&gt;：该头文件主要声明了与互斥量(Mutex)相关的类，包括 std::mutex_* 一系列类，std::lock_guard, std::unique_lock, 以及其他的类型和函数。</p>
<p>④. &lt; condition_variable&gt;：该头文件主要声明了与条件变量相关的类，包括 std::condition_variable 和 std::condition_variable_any。</p>
<p>⑤. &lt; future&gt;：该头文件主要声明了 std::promise, std::package_task 两个 Provider 类，以及 std::future 和 std::shared_future 两个 Future 类，另外还有一些与之相关的类型和函数，std::async() 函数就声明在此头文件中。<br>这里介绍一下std::async() 一一 用来优雅的实现C++异步，一般和std::future()一起使用，前者用于创建异步任务，后者从异步任务中获取结果。</p>
<p>接下来我们就是要具体地学习每一个部分了，不过大部分就是之前学习过，用过的，应该学起来还是很快的。</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/02/13/C++11 并发学习(一)/" class="archive-article-date">
  	<time datetime="2017-02-13T02:58:34.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-02-13</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/concurrency/">concurrency</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/thread/">thread</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="airticle-Linux容器" class="article article-type-airticle" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/18/Linux容器/">Linux容器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>

</p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>简单点说，容器就是一个或多个进程以及他们所能访问的资源的集合。</p>
<p>容器技术的本质是对计算机系统资源的隔离和控制，让原来全局的资源变得只能部分进程之间共享，这跟我们常说的虚拟机这种虚拟化技术没有关系，最新的标准在制定过程中，包括镜像的格式，容器运行时的一些规范具体见<a href="https://www.opencontainers.org/" target="_blank" rel="external">Open Container Initiative(OCI)</a>。</p>
<h2 id="容器和虚拟机"><a href="#容器和虚拟机" class="headerlink" title="容器和虚拟机"></a>容器和虚拟机</h2><p>对于一个接触虚拟机很久的人来说，因为用的 <strong>MAC</strong> ，所以从大一开始我就安装了 <strong>windows</strong> 的虚拟机，当然很大一部分原因是因为要用 <strong>VS</strong> 开始学习编程，但是更多的还是用来打撸了哈哈，后来大二我安装了 <strong>Ubuntu</strong> ，这是我第一次接触Linux系统，虽然感觉和 <strong>macOS</strong> 差不多的样子，但是还是让我深深地爱上了 <strong>Linux</strong> 。</p>
<p>扯得有点远了，其实虚拟机和容器是完全不同的技术，虽然他们都是为了让我们有一个不同的系统来安装我们需要的环境或者是其他，但是从本质上来说容器例如 <strong>Docker</strong> 是一个使用了 <strong>Linux Namespace</strong> 和 <strong>Cgroups</strong> 的虚拟化工具，而虚拟机则是一套完整的系统环境。</p>
<p>我们接下来的学习也是围绕这容器使用到的<br><strong>Namespace</strong> 和 <strong>Cgroups</strong> 这两个经典的 <strong>Linux</strong> 功能来进行的。</p>
<h2 id="容器特点"><a href="#容器特点" class="headerlink" title="容器特点"></a>容器特点</h2><h3 id="不同的Linux发行版可以共享内核"><a href="#不同的Linux发行版可以共享内核" class="headerlink" title="不同的Linux发行版可以共享内核"></a>不同的Linux发行版可以共享内核</h3><blockquote>
<p>当进程开始运行后，进程和内核的交互就是系统调用，当进程需要访问由内核管理的资源时，采用软件中断的方式和内核交互，每个系统调用都有一个中断号，并且这个号不会随着内核版本变化而变化。</p>
</blockquote>
<p>并且Linux内核和应用层进程之间的关系是松耦合的，只要保证两个条件：</p>
<ul>
<li>内核能识别应用层程序的格式</li>
<li>应用层需要的系统调用内核能支持</li>
</ul>
<p>由于Linux下可执行文件和动态库的格式以及系统调用的接口都比较稳定，所以不同的Linux发行版在大部分情况下都可以共享同一个内核</p>
<h3 id="启动迅速"><a href="#启动迅速" class="headerlink" title="启动迅速"></a>启动迅速</h3><blockquote>
<p>容器的本质是一个或多个进程以及他们所能访问的资源的集合。启动一个容器的步骤大概就是：</p>
</blockquote>
<ul>
<li><p>配置好相关资源，如内存、磁盘、网络等配置资源就是往系统中添加一些配置，非常快</p>
</li>
<li><p>初始化容器所用到的文件目录结构由于Linux下有COW（copy on write）的文件系统，如Btrfs、aufs，所以可以很快的根据镜像生成容器的文件系统目录结构。</p>
</li>
<li><p>启动进程和启动一个普通的进程没有区别，对Linux内核来说，所有的应用层进程都是一样的</p>
</li>
</ul>
<p>从上面可以看出启动容器的过程中没有耗时的操作，这也是为什么容器能在毫秒级别启动起来的原因</p>
<p>接下来我们就先来学习 <strong>Namespace</strong> 的相关知识</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/01/18/Linux容器/" class="archive-article-date">
  	<time datetime="2017-01-18T10:13:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-01-18</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cgroup/">cgroup</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/docker/">docker</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/namespace/">namespace</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="airticle-Linux mount(二)" class="article article-type-airticle" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/16/Linux mount(二)/">Linux mount 学习(二)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p></p><p></p>
<h2 id="Shared-subtrees"><a href="#Shared-subtrees" class="headerlink" title="Shared subtrees"></a>Shared subtrees</h2><blockquote>
<p>简单点说， <strong>Shared subtrees</strong> 就是一种控制子挂载点能否在其他地方被看到的技术，它只会在 <strong>bind mount</strong> 和 <strong>mount namespace</strong> 中用到，属于不怎么常用的功能。本篇将以 <strong>bind mount</strong> 为例对 <strong>Shared subtrees</strong> 做一个简单介绍</p>
</blockquote>
<h2 id="Shared-subtrees-1"><a href="#Shared-subtrees-1" class="headerlink" title="Shared subtrees"></a>Shared subtrees</h2><blockquote>
<p>回想一下上一篇中介绍的bind mount部分，如果bind在一起的两个目录下的子目录再挂载了设备的话，他们之间还能相互看到子目录里挂载的内容吗？ 比如在第一个目录下的子目录里面再mount了一个设备，那么在另一个目录下面能看到这个mount的设备里面的东西吗？答案是要看bind mount的propagation type。那什么是propagation type呢？</p>
</blockquote>
<p>peer group和propagation type都是随着shared subtrees一起被引入的概念，下面分别对他们做一个介绍。</p>
<h3 id="peer-group"><a href="#peer-group" class="headerlink" title="peer group"></a>peer group</h3><p>peer group 就是一挂载点的集合，他们之间可以共享挂载信息。</p>
<ul>
<li><p>mount-bind使得源和目的挂载点属于同一个peer group</p>
</li>
<li><p>创建新的mount namespace，新的和老的namespace里相同挂载点就会属于同一个peer group，因为新namespace会拷贝一份老namespace的挂载点信息</p>
</li>
</ul>
<h3 id="propagation-type"><a href="#propagation-type" class="headerlink" title="propagation type"></a>propagation type</h3><blockquote>
<p>这是一个标志，决定修改挂载点的时候会不会影响相同的peer group</p>
</blockquote>
<ul>
<li><p>MS_SHARED: 挂载信息会在同一个peer group的不同挂载点之间共享传播</p>
</li>
<li><p>MS_PRIVATE: 挂载信息根本就不共享，也即private的挂载点不会属于任何peer group</p>
</li>
<li><p>MS_SLAVE: 信息的传播是单向的，在同一个peer group里面，master的挂载点下面发生变化的时候，slave的挂载点下面也跟着变化，但反之则不然，slave下发生变化的时候不会通知master，master不会发生变化。</p>
</li>
<li><p>MS_UNBINDABLE: 这个和MS_PRIVATE相同，只是这种类型的挂载点不能作为bind mount的源，主要用来防止递归嵌套情况的出现</p>
</li>
</ul>
<h3 id="需要注意的地方"><a href="#需要注意的地方" class="headerlink" title="需要注意的地方"></a>需要注意的地方</h3><ul>
<li><p>propagation type是挂载点的属性，每个挂载点都是独立的</p>
</li>
<li><p>挂载点是有父子关系的，比如挂载点/和/mnt/cdrom，/mnt/cdrom都是‘/’的子挂载点，‘/’是/mnt/cdrom的父挂载点</p>
</li>
<li><p>默认情况下，如果父挂载点是MS_SHARED，那么子挂载点也是MS_SHARED的，否则子挂载点将会是MS_PRIVATE，跟爷爷挂载点没有关系</p>
</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">#准备4个虚拟的disk</div><div class="line">kingand67@kelele67:~$ mkdir disks &amp;&amp; cd disks</div><div class="line">&lt;p&gt;</div><div class="line">kingand67@kelele67:~/disks$ dd if=/dev/zero bs=1M count=32 of=./disk1.img</div><div class="line">32+0 records in</div><div class="line">32+0 records out</div><div class="line">33554432 bytes (34 MB, 32 MiB) copied, 0.0203764 s, 1.6 GB/s</div><div class="line">&lt;p&gt;</div><div class="line">kingand67@kelele67:~/disks$ dd if=/dev/zero bs=1M count=32 of=./disk2.img</div><div class="line">32+0 records in</div><div class="line">32+0 records out</div><div class="line">33554432 bytes (34 MB, 32 MiB) copied, 0.0316243 s, 1.1 GB/s</div><div class="line">&lt;p&gt;</div><div class="line">kingand67@kelele67:~/disks$ dd if=/dev/zero bs=1M count=32 of=./disk3.img</div><div class="line">32+0 records in</div><div class="line">32+0 records out</div><div class="line">33554432 bytes (34 MB, 32 MiB) copied, 0.0227662 s, 1.5 GB/s</div><div class="line">&lt;p&gt;</div><div class="line">kingand67@kelele67:~/disks$ dd if=/dev/zero bs=1M count=32 of=./disk4.img</div><div class="line">32+0 records in</div><div class="line">32+0 records out</div><div class="line">33554432 bytes (34 MB, 32 MiB) copied, 0.0322572 s, 1.0 GB/s</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">#并在上面创建ext2文件系统，用于后续的mount测试</div><div class="line">kingand67@kelele67:~/disks$ mkfs.ext2 ./disk1.img</div><div class="line">mke2fs 1.42.13 (17-May-2015)</div><div class="line">Discarding device blocks: done                            </div><div class="line">Creating filesystem with 32768 1k blocks and 8192 inodes</div><div class="line">Filesystem UUID: d34a16ed-3d87-4fa3-adeb-185ca6816a7c</div><div class="line">Superblock backups stored on blocks: </div><div class="line">	8193, 24577</div><div class="line">Allocating group tables: done                            </div><div class="line">Writing inode tables: done                            </div><div class="line">Writing superblocks and filesystem accounting information: done</div><div class="line">&lt;p&gt;</div><div class="line">kingand67@kelele67:~/disks$ mkfs.ext2 ./disk2.img</div><div class="line">mke2fs 1.42.13 (17-May-2015)</div><div class="line">Discarding device blocks: done                            </div><div class="line">Creating filesystem with 32768 1k blocks and 8192 inodes</div><div class="line">Filesystem UUID: 5a615c9b-bb6b-4c56-82ee-24af8efbb3a2</div><div class="line">Superblock backups stored on blocks: </div><div class="line">	8193, 24577</div><div class="line">Allocating group tables: done                            </div><div class="line">Writing inode tables: done                            </div><div class="line">Writing superblocks and filesystem accounting information: done</div><div class="line">&lt;p&gt;</div><div class="line">kingand67@kelele67:~/disks$ mkfs.ext2 ./disk3.img</div><div class="line">mke2fs 1.42.13 (17-May-2015)</div><div class="line">Discarding device blocks: done                            </div><div class="line">Creating filesystem with 32768 1k blocks and 8192 inodes</div><div class="line">Filesystem UUID: c4d0aca6-d952-4d9f-8270-0147a8912cab</div><div class="line">Superblock backups stored on blocks: </div><div class="line">	8193, 24577</div><div class="line">Allocating group tables: done                            </div><div class="line">Writing inode tables: done                            </div><div class="line">Writing superblocks and filesystem accounting information: done</div><div class="line">&lt;p&gt;</div><div class="line">kingand67@kelele67:~/disks$ mkfs.ext2 ./disk4.img</div><div class="line">mke2fs 1.42.13 (17-May-2015)</div><div class="line">Discarding device blocks: done                            </div><div class="line">Creating filesystem with 32768 1k blocks and 8192 inodes</div><div class="line">Filesystem UUID: fa60b67e-4d98-41f3-8db5-27c06882df02</div><div class="line">Superblock backups stored on blocks: </div><div class="line">	8193, 24577</div><div class="line">Allocating group tables: done                            </div><div class="line">Writing inode tables: done                            </div><div class="line">Writing superblocks and filesystem accounting information: done</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#准备两个目录用于挂载上面创建的disk</div><div class="line">kingand67@kelele67:~/disks$ mkdir disk1 disk2</div><div class="line">kingand67@kelele67:~/disks$ ls</div><div class="line">disk1  disk1.img  disk2  disk2.img  disk3.img  disk4.im</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#确保根目录的propagation type是shared，</div><div class="line">#这一步是为了保证大家的操作结果和示例中的一样</div><div class="line">kingand67@kelele67:~/disks$ sudo mount --make-shared /</div></pre></td></tr></table></figure>
<hr>
<h4 id="查看-propagation-type-和-peer-group"><a href="#查看-propagation-type-和-peer-group" class="headerlink" title="查看 propagation type 和 peer group"></a>查看 propagation type 和 peer group</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#显式的以shared方式挂载disk1</div><div class="line">kingand67@kelele67:~/disks$ sudo mount --make-shared ./disk1.img ./disk1</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#显式的以private方式挂载disk2</div><div class="line">kingand67@kelele67:~/disks$ sudo mount --make-private ./disk2.img ./disk2</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#mountinfo比mounts文件包含有更多的关于挂载点的信息</div><div class="line">#这里sed主要用来过滤掉跟当前主题无关的信息</div><div class="line">#shared:111表示挂载点/home/dev/disks/disk1是以shared方式挂载，且peer group id为111</div><div class="line">#而挂载点/home/dev/disks/disk2没有相关信息，表示是以private方式挂载</div><div class="line">kingand67@kelele67:~/disks$ cat /proc/self/mountinfo |grep disk | sed &apos;s/-.*//&apos;</div><div class="line">150 22 7:0 / /home/kingand67/disks/disk1 rw,relatime shared:111 </div><div class="line">156 22 7:1 / /home/kingand67/disks/disk2 rw,relatime</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#分别在disk1和disk2目录下创建目录disk3和disk4，然后挂载disk3，disk4到这两个目录</div><div class="line">kingand67@kelele67:~/disks$ sudo mkdir ./disk1/disk3 ./disk2/disk4</div><div class="line">kingand67@kelele67:~/disks$ sudo mount ./disk3.img ./disk1/disk3</div><div class="line">kingand67@kelele67:~/disks$ sudo mount ./disk4.img ./disk2/disk4</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#查看挂载信息，第一列的数字是挂载点ID，第二例是父挂载点ID，</div><div class="line">#从结果来看，150和162的类型都是shared，而179和173的类型都是private的，</div><div class="line">#说明在默认mount的情况下，子挂载点会继承父挂载点的propagation type</div><div class="line">kingand67@kelele67:~/disks$ cat /proc/self/mountinfo |grep disk | sed &apos;s/-.*//&apos;</div><div class="line">150 22 7:0 / /home/kingand67/disks/disk1 rw,relatime shared:111 </div><div class="line">156 22 7:1 / /home/kingand67/disks/disk2 rw,relatime </div><div class="line">162 150 7:2 / /home/kingand67/disks/disk1/disk3 rw,relatime shared:117 </div><div class="line">293 156 7:3 / /home/kingand67/disks/disk2/disk4 rw,relatime</div></pre></td></tr></table></figure>
<hr>
<h4 id="shared-和-private-mount"><a href="#shared-和-private-mount" class="headerlink" title="shared 和 private mount"></a>shared 和 private mount</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#umount掉disk3和disk4，创建两个新的目录bind1和bind2用于bind测试</div><div class="line">kingand67@kelele67:~/disks$ sudo umount /home/kingand67/disks/disk1/disk3 </div><div class="line">kingand67@kelele67:~/disks$ sudo umount /home/kingand67/disks/disk2/disk4</div><div class="line">kingand67@kelele67:~/disks$ mkdir bind1 bind2</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#bind的方式挂载disk1到bind1，disk2到bind2</div><div class="line">kingand67@kelele67:~/disks$ sudo mount --bind ./disk1 ./bind1</div><div class="line">kingand67@kelele67:~/disks$ sudo mount --bind ./disk2 ./bind2</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#查看挂载信息，显然默认情况下bind1和bind2的propagation type继承自父挂载点22(/)，都是shared。</div><div class="line">#由于bind2的源挂载点disk2是private的，所以bind2没有和disk2在同一个peer group里面，</div><div class="line">#而是重新创建了一个新的peer group，这个group里面就只有它一个。</div><div class="line">#因为150和162都是shared类型且是通过bind方式mount在一起的，所以他们属于同一个peer group 111。</div><div class="line">kingand67@kelele67:~/disks$ cat /proc/self/mountinfo |grep disk | sed &apos;s/-.*//&apos;</div><div class="line">150 22 7:0 / /home/kingand67/disks/disk1 rw,relatime shared:111 </div><div class="line">156 22 7:1 / /home/kingand67/disks/disk2 rw,relatime </div><div class="line">162 22 7:0 / /home/kingand67/disks/bind1 rw,relatime shared:111 </div><div class="line">168 22 7:1 / /home/kingand67/disks/bind2 rw,relatime shared:127</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#ID为24的挂载点为根目录的挂载点</div><div class="line">kingand67@kelele67:~/disks$ cat /proc/self/mountinfo |grep ^22| sed &apos;s/-.*//&apos;</div><div class="line">22 0 8:1 / / rw,relatime shared:1</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#这时disk3和disk4目录都是空的</div><div class="line">kingand67@kelele67:~/disks$ ls bind1/disk3/</div><div class="line">kingand67@kelele67:~/disks$ ls bind2/disk4/</div><div class="line">kingand67@kelele67:~/disks$ ls disk1/disk3/</div><div class="line">kingand67@kelele67:~/disks$ ls disk2/disk4/</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#重新挂载disk3和disk4</div><div class="line">kingand67@kelele67:~/disks$ sudo mount ./disk3.img ./disk1/disk3/</div><div class="line">kingand67@kelele67:~/disks$ sudo mount ./disk4.img ./disk2/disk4/</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#由于disk1/和bind1/属于同一个peer group，</div><div class="line">#所以在挂载了disk3后，在两个目录下都能看到disk3下的内容</div><div class="line">kingand67@kelele67:~/disks$ ls disk1/disk3/</div><div class="line">lost+found</div><div class="line">kingand67@kelele67:~/disks$ ls bind1/disk3/</div><div class="line">lost+found</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#而disk2/是private类型的，所以在他下面挂载disk4不会通知bind2，</div><div class="line">#于是bind2下的disk4目录是空的</div><div class="line">kingand67@kelele67:~/disks$ ls disk2/disk4/</div><div class="line">lost+found</div><div class="line">kingand67@kelele67:~/disks$ ls bind2/disk4/</div><div class="line">kingand67@kelele67:~/disks$</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#再看看disk3，虽然174和175的父挂载点不一样，但由于他们父挂载点属于同一个peer group，</div><div class="line">#且disk3是以默认方式挂载的，所以他们属于同一个peer group</div><div class="line">kingand67@kelele67:~/disks$ cat /proc/self/mountinfo |egrep &quot;disk3&quot;| sed &apos;s/-.*//&apos;</div><div class="line">174 150 7:2 / /home/kingand67/disks/disk1/disk3 rw,relatime shared:133 </div><div class="line">175 162 7:2 / /home/kingand67/disks/bind1/disk3 rw,relatime shared:133</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#umount bind1/disk3后，disk1/disk3也相应的自动umount掉了</div><div class="line">kingand67@kelele67:~/disks$ sudo umount bind1/disk3</div><div class="line">kingand67@kelele67:~/disks$ cat /proc/self/mountinfo | grep disk3</div><div class="line">kingand67@kelele67:~/disks$</div></pre></td></tr></table></figure>
<hr>
<h4 id="slave-mount"><a href="#slave-mount" class="headerlink" title="slave mount"></a>slave mount</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#umount除disk1的所有其他挂载点</div><div class="line">kingand67@kelele67:~/disks$ sudo umount ./disk2/disk4</div><div class="line">kingand67@kelele67:~/disks$ sudo umount /home/kingand67/disks/bind1</div><div class="line">kingand67@kelele67:~/disks$ sudo umount /home/kingand67/disks/bind2</div><div class="line">kingand67@kelele67:~/disks$ sudo umount /home/kingand67/disks/disk2</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#确认只剩disk1</div><div class="line">kingand67@kelele67:~/disks$ cat /proc/self/mountinfo |grep disk| sed &apos;s/-.*//&apos;</div><div class="line">150 22 7:0 / /home/kingand67/disks/disk1 rw,relatime shared:111</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#分别显式的用shared和slave的方式bind disk1</div><div class="line">kingand67@kelele67:~/disks$ sudo mount --bind --make-shared ./disk1 ./bind1</div><div class="line">kingand67@kelele67:~/disks$ sudo mount --bind --make-slave ./bind1 ./bind2</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#150、156和162都属于同一个peer group，</div><div class="line">#master:105表示/home/dev/disks/bind2是peer group 105的slave</div><div class="line">kingand67@kelele67:~/disks$ cat /proc/self/mountinfo |grep disk| sed &apos;s/-.*//&apos;</div><div class="line">150 22 7:0 / /home/kingand67/disks/disk1 rw,relatime shared:111 </div><div class="line">156 22 7:0 / /home/kingand67/disks/bind1 rw,relatime shared:111 </div><div class="line">162 22 7:0 / /home/kingand67/disks/bind2 rw,relatime master:111</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#mount disk3到disk1的子目录disk3下</div><div class="line">kingand67@kelele67:~/disks$ sudo mount ./disk3.img ./disk1/disk3/</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#其他两个目录bin1和bind2里面也挂载成功，说明master发生变化的时候，slave会跟着变化</div><div class="line">kingand67@kelele67:~/disks$ cat /proc/self/mountinfo |grep disk| sed &apos;s/-.*//&apos;</div><div class="line">150 22 7:0 / /home/kingand67/disks/disk1 rw,relatime shared:111 </div><div class="line">156 22 7:0 / /home/kingand67/disks/bind1 rw,relatime shared:111 </div><div class="line">162 22 7:0 / /home/kingand67/disks/bind2 rw,relatime master:111 </div><div class="line">168 150 7:1 / /home/kingand67/disks/disk1/disk3 rw,relatime shared:127 </div><div class="line">170 162 7:1 / /home/kingand67/disks/bind2/disk3 rw,relatime master:127 </div><div class="line">169 156 7:1 / /home/kingand67/disks/bind1/disk3 rw,relatime shared:127</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#umount disk3，然后mount disk3到bind2目录下</div><div class="line">kingand67@kelele67:~/disks$ sudo umount ./disk1/disk3/</div><div class="line">kingand67@kelele67:~/disks$ sudo mount ./disk3.img ./bind2/disk3/</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#由于bind2的propagation type是slave，所以disk1和bind1两个挂载点下面不会挂载disk3</div><div class="line">#从168的类型可以看出，当父挂载点162是slave类型时，默认情况下其子挂载点168是private类型</div><div class="line">kingand67@kelele67:~/disks$ cat /proc/self/mountinfo |grep disk| sed &apos;s/-.*//&apos;</div><div class="line">150 22 7:0 / /home/kingand67/disks/disk1 rw,relatime shared:111 </div><div class="line">156 22 7:0 / /home/kingand67/disks/bind1 rw,relatime shared:111 </div><div class="line">162 22 7:0 / /home/kingand67/disks/bind2 rw,relatime master:111 </div><div class="line">168 162 7:1 / /home/kingand67/disks/bind2/disk3 rw,relatime</div></pre></td></tr></table></figure>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>如果用到了 <strong>bind mount</strong> 和 <strong>mount namespace</strong> ，在挂载设备的时候就需要注意一下父挂载点是否和其他挂载点有 <strong>peer group</strong> 关系，如果有且父挂载点是 <strong>shared</strong> ，就说明你挂载的设备除了在当前挂载点可以看到，在父挂载点的 <strong>peer group</strong> 的下面也可以看到。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://segmentfault.com/a/1190000006899213" target="_blank" rel="external">Linux mount （第二部分）</a></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/01/16/Linux mount(二)/" class="archive-article-date">
  	<time datetime="2017-01-15T18:03:01.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-01-16</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mount/">mount</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  


      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 kelele67
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
<script type="text/javascript">
var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1260501136'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1260501136%26online%3D1%26show%3Dline' type='text/javascript'%3E%3C/script%3E"));
</script>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/"
	}
</script>

<script src="/./main.js"></script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<a href="/tags/CRT/" style="font-size: 14px;">CRT</a> <a href="/tags/algorithm/" style="font-size: 16px;">algorithm</a> <a href="/tags/animation/" style="font-size: 14px;">animation</a> <a href="/tags/buffer-manipulation/" style="font-size: 10px;">buffer manipulation</a> <a href="/tags/c/" style="font-size: 20px;">c</a> <a href="/tags/c/" style="font-size: 16px;">c++</a> <a href="/tags/ccache/" style="font-size: 10px;">ccache</a> <a href="/tags/cgroup/" style="font-size: 10px;">cgroup</a> <a href="/tags/concurrency/" style="font-size: 16px;">concurrency</a> <a href="/tags/data-structures/" style="font-size: 10px;">data structures</a> <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/gc/" style="font-size: 14px;">gc</a> <a href="/tags/html5/" style="font-size: 10px;">html5</a> <a href="/tags/http/" style="font-size: 10px;">http</a> <a href="/tags/ios/" style="font-size: 10px;">ios</a> <a href="/tags/linux/" style="font-size: 18px;">linux</a> <a href="/tags/lua/" style="font-size: 14px;">lua</a> <a href="/tags/make/" style="font-size: 10px;">make</a> <a href="/tags/mount/" style="font-size: 12px;">mount</a> <a href="/tags/namespace/" style="font-size: 10px;">namespace</a> <a href="/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/tags/python/" style="font-size: 16px;">python</a> <a href="/tags/release/" style="font-size: 10px;">release</a> <a href="/tags/search/" style="font-size: 10px;">search</a> <a href="/tags/siri/" style="font-size: 10px;">siri</a> <a href="/tags/solution/" style="font-size: 10px;">solution</a> <a href="/tags/sort/" style="font-size: 10px;">sort</a> <a href="/tags/string-manipulation/" style="font-size: 10px;">string manipulation</a> <a href="/tags/swift/" style="font-size: 14px;">swift</a> <a href="/tags/systemd/" style="font-size: 10px;">systemd</a> <a href="/tags/sysvinit/" style="font-size: 10px;">sysvinit</a> <a href="/tags/thread/" style="font-size: 12px;">thread</a> <a href="/tags/threadpool/" style="font-size: 12px;">threadpool</a> <a href="/tags/tmpfs/" style="font-size: 10px;">tmpfs</a> <a href="/tags/trees/" style="font-size: 10px;">trees</a> <a href="/tags/ubuntu/" style="font-size: 10px;">ubuntu</a> <a href="/tags/upstart/" style="font-size: 10px;">upstart</a> <a href="/tags/web-server/" style="font-size: 10px;">web server</a> <a href="/tags/zookeeper/" style="font-size: 12px;">zookeeper</a> <a href="/tags/随笔/" style="font-size: 10px;">随笔</a>
    			</div>
    	</section>
    

    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">&lt;div class=&quot;text&quot; style=&quot; text-align:center;&quot;&gt;大三学生&lt;br&gt;就读于重庆大学 软件狗&lt;br&gt;&lt;br&gt; 喜欢python&lt;br&gt;自由的灵魂&lt;br&gt;&lt;br&gt;世界万物都是隐喻&lt;br&gt;我们是通过隐喻这个装置接受反讽&lt;br&gt;加深扩大自己&lt;/div&gt;</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>
