<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>树犹如此|人何以堪</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="做一个富有的废物">
<meta property="og:type" content="website">
<meta property="og:title" content="树犹如此|人何以堪">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="树犹如此|人何以堪">
<meta property="og:description" content="做一个富有的废物">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="树犹如此|人何以堪">
<meta name="twitter:description" content="做一个富有的废物">
  
  
    <link rel="icon" href="//favicon.png">
  
  <script src="/style.js"></script>
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="http://oe9uedqb2.bkt.clouddn.com/4D9F59FD6F416AF4A92C4B977580BD95.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">kelele67</a></h1>
		</hgroup>

		
		<p class="header-subtitle">做一个富有的废物</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="/about">关于本站</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">标签</a>
    			
    			
            
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/kelele67" title="github">github</a>
		        
					<a class="weibo" target="_blank" href="http://weibo.com/kelele67" title="weibo">weibo</a>
		        
					<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/liu-qi-21-51" title="zhihu">zhihu</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">kelele67</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="http://oe9uedqb2.bkt.clouddn.com/4D9F59FD6F416AF4A92C4B977580BD95.png" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">kelele67</h1>
			</hgroup>
			
			<p class="header-subtitle">做一个富有的废物</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/about">关于本站</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/kelele67" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/kelele67" title="weibo">weibo</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/liu-qi-21-51" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        
  
    <article id="airticle-面试准备(一)一一计算机网络" class="article article-type-airticle" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/21/面试准备(一)一一计算机网络/">面试准备(一)一一计算机网络之TCP</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>

<blockquote>
<p>此系列文章纯属虚构、单纯的（把面试官都归为是好伙计值得聊而不是脸上写着：呵呵你个菜鸡，心里想着：老子天下无敌 的那种，不过事实上个人感觉后者会比较多，毕竟如果自己不够强的话也只能吃个哑巴亏）想象面试官会问你什么问题，也是自己大三以来专注面试所收集到的一些小小的情报</p>
</blockquote>
</p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><ul>
<li><p>字节流协议</p>
</li>
<li><p>三次握手、四次挥手</p>
</li>
<li><p>重点在于能够清楚讲出TCP的11种状态变迁（CLOSING状态比较罕见，忽略）</p>
</li>
</ul>
<h3 id="TCP过程"><a href="#TCP过程" class="headerlink" title="TCP过程"></a>TCP过程</h3><p>提供一个思路过程（不够细致严谨，仅适用于让你讲的清除）：</p>
<p>三次握手</p>
<p>首先客户端和服务端都是关闭的<br>     ↓       ↓<br>  主动打开   被动打开<br>此时客户端状态为 <strong>SYN_SENT</strong> 、服务端状态从 <strong>LISTEN</strong> 状态 到 <strong>SYN_RCVD</strong><br>     ↓①                              ↓②<br> 发送一个SYN J                  发送SYN K 和ACK J+1<br>此时客户端和服务端状态都为 <strong>ESTABLISHED</strong> ，他们进行数据传输<br>     ↓③<br> 发送一个ACK K+1</p>
<p>四次挥手：</p>
<p>首先客户端和服务端都是连接的<br>     ↓        ↓<br>  主动关闭    被动关闭<br>此时客户端状态为 <strong>FIN_WAIT1</strong> 、服务端状态为 <strong>CLOSED_WAIT</strong><br>     ↓①                    ↓②<br>发送一个FIN M          发送一个ACK M+1<br>此时服务端状态为 <strong>LAST_ACK</strong> 、客户端状态为 <strong>FIN_WAIT2</strong><br>     ↓③                     ↓④<br>发送一个FIN N          发送一个ACK N+1<br>此时客户端状态为 <strong>TIME_WAIT</strong> 、服务端状态为 <strong>CLOSED</strong></p>
<h3 id="TIME-WAIT"><a href="#TIME-WAIT" class="headerlink" title="TIME_WAIT"></a>TIME_WAIT</h3><blockquote>
<p>这时，你就会被问到TIME_WAIT的相关知识 如果没被问到，你就自己说了吧</p>
</blockquote>
<p>主要说说设置TIME_WAIT的原因吧</p>
<ul>
<li>设置TIME_WAIT的原因</li>
</ul>
<p>从两个方面来说吧，首先可靠地实现TCP全双工连接(这里可以用英文说 full duplex)的终止，因为客户端需要维持这个TIME_WAIT这个将关未关的状态来发送最后一个ACK，(这让我想到了中学生物书那个奄奄一息在生命的最后关头完成交配保留了自己染色体为遗传学研究做出了巨大贡献的果蝇hhh)，如果它直接CLOSED的话，客户端会相应一个RST(进阶)，服务器收到后会响应一个错误</p>
<p>第二个方面是TIME_WAIT允许了旧的重复分节在网络中消逝，因为在这个状态下的客户端不允许启动新的连接，而这个状态持续2MSL(进阶)，于是就保证了当建立新的TCP连接的时候，旧的重复分节在网络中消逝。</p>
<ul>
<li>大量的TIME_WAIT</li>
</ul>
<p>在HTTP协议中，关闭TCP连接的是Server端，这样，Server端会进入TIME_WAIT状态，可想而知，对于访问量大的Web Server，会存在大量的TIME_WAIT状态。</p>
<p>解决办法：<br>①. 开启socket重用，允许将TIME_WAIT的socket重新用于TCP连接<br>②. 开启快速回收。</p>
<blockquote>
<p>然后你就被问到 TCP为什么需要3次握手与4次挥手</p>
</blockquote>
<p>三次握手：为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误</p>
<p>四次挥手：因为tcp是全双工模式(这里可以用英文说 full duplex)，接收到FIN时意味将没有数据再发来，但是还是可以继续发送数据。</p>
<h2 id="TCP进阶"><a href="#TCP进阶" class="headerlink" title="TCP进阶"></a>TCP进阶</h2><p>每个状态一句话简洁解释，可以把这个嵌入到前面的部分：</p>
<h3 id="三次握手状态："><a href="#三次握手状态：" class="headerlink" title="三次握手状态："></a>三次握手状态：</h3><ul>
<li><p>LISTEN:<br>表示服务器端的某个SOCKET处于监听状态。 </p>
</li>
<li><p>SYN_SENT: 当客户端SOCKET执行CONNECT连接时，发送SYN，随即进入到SYN_SENT，并等待服务端发送的SYN, ACK</p>
</li>
<li><p>SYN_RCVD:<br>服务端接受到了SYN报文。</p>
</li>
</ul>
<blockquote>
<p>在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂，基本上用netstat你是很难看到这种状态的，除非你特意写了一个客户端测试程序，故意将三次TCP握手过程中最后一个 ACK报文不予发送。因此这种状态时，当收到客户端的ACK报文后，它会进入到ESTABLISHED状态。（服务器端）</p>
</blockquote>
<ul>
<li>ESTABLISHED：表示连接已经建立了。</li>
</ul>
<h3 id="四次挥手状态："><a href="#四次挥手状态：" class="headerlink" title="四次挥手状态："></a>四次挥手状态：</h3><ul>
<li>FIN_WAIT_1:<br>表示等待对方的FIN报文。</li>
</ul>
<blockquote>
<p>其实FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1状态一般是比较难见到的，而FIN_WAIT_2状态还有时常常可以用netstat看到。（主动方）</p>
</blockquote>
<ul>
<li>FIN_WAIT_2：<br>对方回应ACK报文后，则进入到FIN_WAIT_2状态。</li>
</ul>
<blockquote>
<p>上面已经详细解释了这种状态，实际上FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你(ACK信息)，稍后再关闭连接。（主动方）</p>
</blockquote>
<ul>
<li>TIME_WAIT:<br>收到了对方的FIN报文，并发送出了ACK报文，即将CLOSED。</li>
</ul>
<blockquote>
<p>表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FIN_WAIT_1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。（主动方）</p>
</blockquote>
<ul>
<li>CLOSING（比较少见）:<br>表示双方都正在关闭SOCKET连接</li>
</ul>
<blockquote>
<p>这种状态比较特殊，实际情况中应该是很少见，属于一种比较罕见的例外状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到（或同时收到）对方的 ACK报文，再收到对方的FIN报文。但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？其实细想一下，也不难得出结论：那就是如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接。</p>
</blockquote>
<ul>
<li>CLOSE_WAIT:<br>这种状态的含义其实是表示在等待关闭。</li>
</ul>
<blockquote>
<p>当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以 close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接。（被动方）</p>
</blockquote>
<ul>
<li>LAST_ACK:<br>等待最后一个ACK，即将CLOSED。</li>
</ul>
<blockquote>
<p>这个状态还是比较容易好理解的，它是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。（被动方）</p>
</blockquote>
<ul>
<li>CLOSED:<br>表示连接中断。</li>
</ul>
<p>下面这两个术语也是之前有提到的，如果不熟悉可以不提：</p>
<h3 id="RST"><a href="#RST" class="headerlink" title="RST"></a>RST</h3><p>在TCP协议中RST表示复位，用来异常的关闭连接，在TCP的设计中它是不可或缺的。发送RST包关闭连接时，不必等缓冲区的包都发出去，直接就丢弃缓存区的包发送RST包。而接收端收到RST包后，也不必发送ACK包来确认。</p>
<h3 id="MSL"><a href="#MSL" class="headerlink" title="MSL"></a>MSL</h3><p>MSL(Maximum Segment Lifetime)报文最长存活时间</p>
<h2 id="TCP高端"><a href="#TCP高端" class="headerlink" title="TCP高端"></a>TCP高端</h2><p>适用于BAT等公司，不过感觉这些问题真的是对于软件工程的学生来说有点难了，本人也是一知半解，但不排除还是会被之前说到的第二种面试官所问到，或者他是为了提醒你不要骄傲还是有很多东西要学的</p>
<h3 id="tcp窗口滑动以及拥塞控制"><a href="#tcp窗口滑动以及拥塞控制" class="headerlink" title="tcp窗口滑动以及拥塞控制"></a>tcp窗口滑动以及拥塞控制</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.csdn.net/xifeijian/article/details/12777187" target="_blank" rel="external">TCP为什么需要3次握手与4次挥手</a><br><a href="http://blog.chinaunix.net/uid-26275986-id-4109679.html" target="_blank" rel="external">tcp窗口滑动以及拥塞控制</a></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/04/21/面试准备(一)一一计算机网络/" class="archive-article-date">
  	<time datetime="2017-04-21T05:20:04.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-04-21</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http/">http</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tcp/">tcp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/udp/">udp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面试/">面试</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="airticle-深入 Lua Garbage Collector(四)" class="article article-type-airticle" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/15/深入 Lua Garbage Collector(四)/">深入 Lua Garbage Collector(四)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p></p>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/04/15/深入 Lua Garbage Collector(四)/" class="archive-article-date">
  	<time datetime="2017-04-15T05:14:22.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-04-15</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/gc/">gc</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/lua/">lua</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="airticle-深入 Lua Garbage Collector(三)" class="article article-type-airticle" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/14/深入 Lua Garbage Collector(三)/">深入 Lua Garbage Collector(三)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>

</p><h2 id="Lua-源码"><a href="#Lua-源码" class="headerlink" title="Lua 源码"></a>Lua 源码</h2><p>阅读的源码来自 <strong>lua-5.3.0</strong></p>
<h3 id="GC对象"><a href="#GC对象" class="headerlink" title="GC对象"></a>GC对象</h3><p>在 Lua 中，一共只有 9 种数据类型：</p>
<ul>
<li>nil </li>
<li>boolean </li>
<li>lightuserdata </li>
<li>number </li>
<li>string </li>
<li>table  </li>
<li>function  </li>
<li>userdata  </li>
<li>thread </li>
</ul>
<blockquote>
<p>其中，只有 <strong>string table function thread</strong> 四种在 <strong>vm</strong> 中以引用方式共享，是需要被 <strong>GC</strong> 管理回收的对象。其它类型都以值形式存在。</p>
<p>但在 <strong>Lua</strong> 的实现中，还有两种类型的对象需要被 <strong>GC</strong> 管理。分别是 <strong>proto</strong> （可以看作未绑定 upvalue 的函数）， <strong>upvalue</strong> （多个 upvalue 会引用同一个值）。</p>
</blockquote>
<h3 id="保存值的形式"><a href="#保存值的形式" class="headerlink" title="保存值的形式"></a>保存值的形式</h3><p>Lua 是以 union + type 的形式保存值</p>
<p>在lobject.h中<br>96行<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">** Union of all Lua values</div><div class="line">*/</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> Value Value;</div></pre></td></tr></table></figure></p>
<hr>
<p>101-108行<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">*</div><div class="line">** Tagged Values. This is the basic representation of values in Lua,</div><div class="line">** an actual value plus a tag with its type.</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> TValuefields    Value value_; int tt_</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> lua_TValue TValue;</div></pre></td></tr></table></figure></p>
<hr>
<p>279-286行<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">union</span> Value &#123;</div><div class="line">  GCObject *gc;    <span class="comment">/* collectable objects */</span></div><div class="line">  <span class="keyword">void</span> *p;         <span class="comment">/* light userdata */</span></div><div class="line">  <span class="keyword">int</span> b;           <span class="comment">/* booleans */</span></div><div class="line">  lua_CFunction f; <span class="comment">/* light C functions */</span></div><div class="line">  lua_Integer i;   <span class="comment">/* integer numbers */</span></div><div class="line">  lua_Number n;    <span class="comment">/* float numbers */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<hr>
<p>我们可以看到，Value 以 union 方式定义。如果是需要被 GC 管理的对象，就以 GCObject 指针形式保存，否则直接存值。在代码的其它部分，并不直接使用 Value 类型，而是 TValue 类型。它比 Value 多了一个类型标识。用 int tt 记录。通常的系统中，每个 TValue 长为 12 字节。</p>
<p>这里作者也有提到在 32 位系统下，为何不用某种 trick 把 type 压缩到前 8 字节内<br>具体考虑到的是可移植性的原因：</p>
<blockquote>
<p>Several dynamically-typed languages (e.g., the original implementa-<br>tion of Smalltalk80 [9]) use spare bits in each pointer to store the value’s type tag. This trick works in most machines because, due to alignment, the last two or three bits of a pointer are always zero, and therefore can be used for other purposes. However, this technique is neither portable nor implementable in ANSI C.<br>The C standard does not even ensures that a pointer ts in any integral type<br>and so there is no standard way to perform bit manipulation over pointers.</p>
</blockquote>
<h3 id="GCObject"><a href="#GCObject" class="headerlink" title="GCObject"></a>GCObject</h3><p>所有的 <strong>GCObject</strong> 都有一个相同的数据头，叫作 <strong>CommonHeader</strong> 。</p>
<p>在lobject.h里81行我们可以找到它的定义。使用宏定义的目的是为了能够包含在其他的object中。C 语言不支持结构的继承。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">** Common Header for all collectable objects (in macro form, to be</div><div class="line">** included in other objects)</div><div class="line">*/</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> CommonHeader    GCObject *next; lu_byte tt; lu_byte marked</span></div></pre></td></tr></table></figure></p>
<hr>
<blockquote>
<p>从这里我们可以看到：所有的 GCObject 都用一个单向链表串了起来。每个对象都以 tt 来识别其类型。marked 域用于标记清除的工作。</p>
<p>标记清除算法是一种简单的 GC 算法。每次 GC 过程，先以若干根节点开始，逐个把直接以及间接和它们相关的节点都做上标记。对于 Lua ，这个过程很容易实现。因为所有 GObject 都在同一个链表上，当标记完成后，遍历这个链表，把未被标记的节点一一删除即可。</p>
<p>实际上，Lua不只用一条链表来保存所有的 GCObject 。这是因为我们要清除的string table function thread中的 string 类型有其特殊性。<br>所有的 string 放在一张大的 hash 表中。它需要保证系统中不会有值相同的 string 被创建两份。<br>所以 string 是被单独管理的，而不串在 GCObject 的链表中。</p>
</blockquote>
<h3 id="lua-State"><a href="#lua-State" class="headerlink" title="lua_State"></a>lua_State</h3><p>lua_State 是 Lua 虚拟机的外在数据形式，取名 State 意为 Lua虚拟机 的当前状态。全局 State 引用了整个虚拟机的所有数据。而虚拟机的运转恰恰是 Lua 的核心部分。这个全局 State 定义在 lstate.h 中149-172行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">** 'per thread' state</div><div class="line">*/</div><div class="line"><span class="keyword">struct</span> lua_State &#123;</div><div class="line">  CommonHeader;</div><div class="line">  lu_byte status;</div><div class="line">  StkId top;  <span class="comment">/* first free slot in the stack */</span></div><div class="line">  global_State *l_G;</div><div class="line">  CallInfo *ci;  <span class="comment">/* call info for current function */</span></div><div class="line">  <span class="keyword">const</span> Instruction *oldpc;  <span class="comment">/* last pc traced */</span></div><div class="line">  StkId stack_last;  <span class="comment">/* last free slot in the stack */</span></div><div class="line">  StkId <span class="built_in">stack</span>;  <span class="comment">/* stack base */</span></div><div class="line">  UpVal *openupval;  <span class="comment">/* list of open upvalues in this stack */</span></div><div class="line">  GCObject *gclist;</div><div class="line">  <span class="keyword">struct</span> lua_State *twups;  <span class="comment">/* list of threads with open upvalues */</span></div><div class="line">  <span class="keyword">struct</span> lua_longjmp *errorJmp;  <span class="comment">/* current error recover point */</span></div><div class="line">  CallInfo base_ci;  <span class="comment">/* CallInfo for first level (C calling Lua) */</span></div><div class="line">  lua_Hook hook;</div><div class="line">  <span class="keyword">ptrdiff_t</span> errfunc;  <span class="comment">/* current error handling function (stack index) */</span></div><div class="line">  <span class="keyword">int</span> stacksize;</div><div class="line">  <span class="keyword">int</span> basehookcount;</div><div class="line">  <span class="keyword">int</span> hookcount;</div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> nny;  <span class="comment">/* number of non-yieldable calls in stack */</span></div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> nCcalls;  <span class="comment">/* number of nested C calls */</span></div><div class="line">  lu_byte hookmask;</div><div class="line">  lu_byte allowhook;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>一个完整的 lua 虚拟机在运行时，可有多个 lua_State ，即多个 thread 。它们会共享一些数据。这些数据放在 global_State *l_G 域中。其中自然也包括所有 GCobject 的链表。</p>
</blockquote>
<h3 id="allgc"><a href="#allgc" class="headerlink" title="allgc"></a>allgc</h3><blockquote>
<p>所有的 string 则以 stringtable 结构保存在 stringtable strt 域。string 的值类型为 TString ，它和其它 GCObject 一样，拥有 CommonHeader 。但需要注意，CommonHeader 中的 next 域却和其它类型的单向链表意义不同。它被挂接在 stringtable 这个 hash 表中。</p>
<p>除 string 外的 GCObject 链表头放在 allgc 域中<br>在  lstate.h 122 行：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GCObject *allgc;  <span class="comment">/* list of all collectable objects */</span></div></pre></td></tr></table></figure></p>
</blockquote>
<hr>
<p>。初始化时，这个域被初始化为主线程。见 lstate.c 253 行，lua_newthread 函数中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* link it on list 'allgc' */</span></div><div class="line">L1-&gt;next = g-&gt;allgc;</div><div class="line">g-&gt;allgc = obj2gco(L1);</div></pre></td></tr></table></figure></p>
<hr>
<h3 id="link函数"><a href="#link函数" class="headerlink" title="link函数"></a>link函数</h3><p>每当一个新的 GCobject 被创建出来，都会被挂接到这个链表上，link函数主要是：</p>
<p>lgc.c 145-206行<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">luaC_barrier_</span> <span class="params">(lua_State *L, GCObject *o, GCObject *v)</span> </span>&#123;</div><div class="line">  global_State *g = G(L);</div><div class="line">  lua_assert(isblack(o) &amp;&amp; iswhite(v) &amp;&amp; !isdead(g, v) &amp;&amp; !isdead(g, o));</div><div class="line">  <span class="keyword">if</span> (keepinvariant(g))  <span class="comment">/* must keep invariant? */</span></div><div class="line">    reallymarkobject(g, v);  <span class="comment">/* restore invariant */</span></div><div class="line">  <span class="keyword">else</span> &#123;  <span class="comment">/* sweep phase */</span></div><div class="line">    lua_assert(issweepphase(g));</div><div class="line">    makewhite(g, o);  <span class="comment">/* mark main obj. as white to avoid other barriers */</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">luaC_upvalbarrier_</span> <span class="params">(lua_State *L, UpVal *uv)</span> </span>&#123;</div><div class="line">  global_State *g = G(L);</div><div class="line">  GCObject *o = gcvalue(uv-&gt;v);</div><div class="line">  lua_assert(!upisopen(uv));  <span class="comment">/* ensured by macro luaC_upvalbarrier */</span></div><div class="line">  <span class="keyword">if</span> (keepinvariant(g))</div><div class="line">    markobject(g, o);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">GCObject *<span class="title">luaC_newobj</span> <span class="params">(lua_State *L, <span class="keyword">int</span> tt, <span class="keyword">size_t</span> sz)</span> </span>&#123;</div><div class="line">  global_State *g = G(L);</div><div class="line">  GCObject *o = cast(GCObject *, luaM_newobject(L, novariant(tt), sz));</div><div class="line">  o-&gt;marked = luaC_white(g);</div><div class="line">  o-&gt;tt = tt;</div><div class="line">  o-&gt;next = g-&gt;allgc;</div><div class="line">  g-&gt;allgc = o;</div><div class="line">  <span class="keyword">return</span> o;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>upvalue 在 C 中类型为 UpVal ，也是一个 GCObject 。但这里被特殊处理。为什么会这样？因为 Lua 的 GC可以分步扫描。别的类型被新创建时，都可以直接作为一个白色节点（新节点）挂接在整个系统中。但 upvalue 却是对已有的对象的间接引用，不是新数据。一旦 GC 在 mark 的过程中（ gc 状态为 GCSpropagate ），则需增加屏障 luaC_barrier 。对于这个问题，会在以后详细展开。</p>
</blockquote>
<h3 id="userdata"><a href="#userdata" class="headerlink" title="userdata"></a>userdata</h3><p>lua 还有另一种数据类型创建时的挂接过程也被特殊处理。那就是 userdata 。<br>见 lstring.c 的 170 行：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function">Udata *<span class="title">luaS_newudata</span> <span class="params">(lua_State *L, <span class="keyword">size_t</span> s)</span> </span>&#123;</div><div class="line">  Udata *u;</div><div class="line">  GCObject *o;</div><div class="line">  <span class="keyword">if</span> (s &gt; MAX_SIZE - <span class="keyword">sizeof</span>(Udata))</div><div class="line">    luaM_toobig(L);</div><div class="line">  o = luaC_newobj(L, LUA_TUSERDATA, sizeludata(s));</div><div class="line">  u = gco2u(o);</div><div class="line">  u-&gt;len = s;</div><div class="line">  u-&gt;metatable = <span class="literal">NULL</span>;</div><div class="line">  setuservalue(L, u, luaO_nilobject);</div><div class="line">  <span class="keyword">return</span> u;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>这里调用 luaC_newobj 来挂接新的 Udata 对象，但是把所有 userdata 全部挂接在其它类型之后</p>
<p>这样做的原因是：<br>所有 userdata 都可能有 gc 方法（其它类型则没有）。需要统一去调用这些 gc 方面，则应该有一个途径来单独遍历所有的 userdata 。除此之外，userdata 和其它 GCObject 的处理方式则没有区别，故依旧挂接在整个 GCObject 链表上而不需要单独再分出一个链表。<br>处理 userdata 的流程见 lgc.c 的 860 行<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">** move all unreachable objects (or 'all' objects) that need</div><div class="line">** finalization from list 'finobj' to list 'tobefnz' (to be finalized)</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">separatetobefnz</span> <span class="params">(global_State *g, <span class="keyword">int</span> all)</span> </span>&#123;</div></pre></td></tr></table></figure></p>
<p>这个函数会把所有带有 gc 方法的 userdata 挑出来，放到一个循环链表中。在Lua5.3中，这个循环链表在 global_State 的 tobefnz 域。需要调用 gc 方法的这些 userdata 在当个 gc 循环是不能被直接清除的。所以在 mark 环节的最后，会被重新 mark 为不可清除节点。<br>见 lgc.c 的 285 行：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">** mark all objects in list of being-finalized</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">markbeingfnz</span> <span class="params">(global_State *g)</span> </span>&#123;</div><div class="line">  GCObject *o;</div><div class="line">  <span class="keyword">for</span> (o = g-&gt;tobefnz; o != <span class="literal">NULL</span>; o = o-&gt;next)</div><div class="line">    markobject(g, o);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样，可以保证在调用 gc 方法环节，这些对象的内存都没有被释放。但因为这些对象被设置了 finalized 标记。（通过 markfinalized ），下一次 gc 过程不会进入 tmudata 链表，将会被正确清理。</p>
<p>具体 userdata 的清理流程，会在后面展开解释。</p>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.codingnow.com/2011/03/lua_gc_1.html" target="_blank" rel="external">云风的 BLOG</a></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/04/14/深入 Lua Garbage Collector(三)/" class="archive-article-date">
  	<time datetime="2017-04-14T14:20:02.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-04-14</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/gc/">gc</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/lua/">lua</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="airticle-深入 Lua Garbage Collector(二)" class="article article-type-airticle" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/14/深入 Lua Garbage Collector(二)/">深入 Lua Garbage Collector(二)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>

</p><p>这一篇我们主要介绍一下 <strong>Lua</strong> 的 <strong>GC</strong> 机制</p>
<h2 id="Lua垃圾回收器函数"><a href="#Lua垃圾回收器函数" class="headerlink" title="Lua垃圾回收器函数"></a>Lua垃圾回收器函数</h2><p><strong>Lua</strong> 提供了以下函数 <strong>collectgarbage ([opt [, arg]])</strong> 用来控制自动内存管理:</p>
<ul>
<li><p>collectgarbage(“collect”): 做一次完整的垃圾收集循环。通过参数 opt 它提供了一组不同的功能：</p>
</li>
<li><p>collectgarbage(“count”): 以 K 字节数为单位返回 Lua 使用的总内存数。 这个值有小数部分，所以只需要乘上 1024 就能得到 Lua 使用的准确字节数（除非溢出）。</p>
</li>
<li><p>collectgarbage(“restart”): 重启垃圾收集器的自动运行。</p>
</li>
<li><p>collectgarbage(“setpause”): 将 arg 设为收集器的 间歇率 。 返回 间歇率 的前一个值。</p>
</li>
<li><p>collectgarbage(“setstepmul”): 返回 步进倍率 的前一个值。</p>
</li>
<li><p>collectgarbage(“step”): 单步运行垃圾收集器。 步长”大小”由 arg 控制。 传入 0 时，收集器步进（不可分割的）一步。 传入非 0 值， 收集器收集相当于 Lua 分配这些多（K 字节）内存的工作。 如果收集器结束一个循环将返回 true 。</p>
</li>
<li><p>collectgarbage(“stop”): 停止垃圾收集器的运行。 在调用重启前，收集器只会因显式的调用运行。</p>
</li>
</ul>
<p>以下演示了一个简单的垃圾回收实例:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">mytable = &#123;<span class="string">"apple"</span>, <span class="string">"orange"</span>, <span class="string">"banana"</span>&#125;</div><div class="line"></div><div class="line"><span class="built_in">print</span>(<span class="built_in">collectgarbage</span>(<span class="string">"count"</span>))</div><div class="line"></div><div class="line">mytable = <span class="keyword">nil</span></div><div class="line"></div><div class="line"><span class="built_in">print</span>(<span class="built_in">collectgarbage</span>(<span class="string">"count"</span>))</div><div class="line"></div><div class="line"><span class="built_in">print</span>(<span class="built_in">collectgarbage</span>(<span class="string">"collect"</span>))</div><div class="line"></div><div class="line"><span class="built_in">print</span>(<span class="built_in">collectgarbage</span>(<span class="string">"count"</span>))</div></pre></td></tr></table></figure>
<hr>
<h2 id="基本算法"><a href="#基本算法" class="headerlink" title="基本算法"></a>基本算法</h2><p>基本算法就是我们之前的 <strong>Mark &amp; Sweep</strong></p>
<blockquote>
<p>首先，系统管理着所有已经创建了的对象。每个对象都有对其他对象的引用。 <strong>root</strong> 集合代表着已知的系统级别的对象引用。我们从 <strong>root</strong> 集合出发，就可以访问到系统引用到的所有对象。而没有被访问到的对象就是垃圾对象，需要被销毁。</p>
</blockquote>
<p>我们可以将所有对象分成三个状态：</p>
<p>①. White状态，也就是待访问状态。表示对象还没有被垃圾回收的标记过程访问到。</p>
<p>②. Gray状态，也就是待扫描状态。表示对象已经被垃圾回收访问到了，但是对象本身对于其他对象的引用还没有进行遍历访问。</p>
<p>③. Black状态，也就是已扫描状态。表示对象已经被访问到了，并且也已经遍历了对象本身对其他对象的引用</p>
<p>伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">当前所有对象都是White状态;  </div><div class="line">将root集合引用到的对象从White设置成Gray，并放到Gray集合中;  </div><div class="line">while(Gray集合不为空)  </div><div class="line">&#123;  </div><div class="line">    从Gray集合中移除一个对象O，并将O设置成Black状态;  </div><div class="line">    for(O中每一个引用到的对象O1) &#123;  </div><div class="line">        if(O1在White状态) &#123;  </div><div class="line">            将O1从White设置成Gray，并放到到Gray集合中；  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">for(任意一个对象O)&#123;  </div><div class="line">    if(O在White状态)  </div><div class="line">        销毁对象O;  </div><div class="line">    else  </div><div class="line">        将O设置成White状态;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="Incremental-Garbage-Collection"><a href="#Incremental-Garbage-Collection" class="headerlink" title="Incremental Garbage Collection"></a>Incremental Garbage Collection</h2><blockquote>
<p>上面的算法如果一次性执行，在对象很多的情况下，会执行很长时间，严重影响程序本身的响应速度。其中一个解决办法就是，可以将上面的算法分步执行，这样每个步骤所耗费的时间就比较小了。我们可以将上述算法改为以下下几个步骤:</p>
</blockquote>
<ol>
<li><p>首先标识所有的 <strong>root</strong> 对象</p>
</li>
<li><p>遍历访问所有的 <strong>gray</strong> 对象。如果超出了本次计算量上限，退出等待下一次遍历</p>
</li>
<li><p>销毁垃圾对象</p>
</li>
</ol>
<blockquote>
<p>在每个步骤之间，由于程序可以正常执行，所以会破坏当前对象之间的引用关系。black对象表示已经被扫描的对象，所以他应该不可能引用到一个white对象。当程序的改变使得一个black对象引用到一个white对象时，就会造成错误。解决这个问题的办法就是设置barrier。barrier在程序正常运行过程中，监控所有的引用改变。如果一个black对象需要引用一个white对象，存在两种处理办法：</p>
</blockquote>
<p>①. 将white对象设置成gray，并添加到gray列表中等待扫描。这样等于帮助整个GC的标识过程向前推进了一步。<br>②. 将black对象该回成gray，并添加到gray列表中等待扫描。这样等于使整个GC的标识过程后退了一步。</p>
<blockquote>
<p>这种垃圾回收方式被称为 <strong>Incremental Garbage Collection</strong> (简称为 <strong>IGC</strong> ， <strong>Lua</strong>所采用的就是这种方法。使用 <strong>IGC</strong> 并不是没有代价的。 <strong>IGC</strong> 所检测出来的垃圾对象集合比实际的集合要小，也就是说，有些在 <strong>GC</strong> 过程中变成垃圾的对象，有可能在本轮 <strong>GC</strong> 中检测不到。不过，这些残余的垃圾对象一定会在下一轮 <strong>GC</strong> 被检测出来，不会造成泄露。</p>
</blockquote>
<p>在下一篇中我们将会具体的来看一看 <strong>Lua</strong> 的 <strong>GC源码</strong></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/04/14/深入 Lua Garbage Collector(二)/" class="archive-article-date">
  	<time datetime="2017-04-14T02:50:02.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-04-14</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/gc/">gc</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/lua/">lua</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="airticle-深入 Lua Garbage Collector(一)" class="article article-type-airticle" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/13/深入 Lua Garbage Collector(一)/">深入 Lua Garbage Collector(一)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p></p><p><br>看到一个 <strong>Bob Nystrom</strong> 写的<a href="http://journal.stuffwithstuff.com/2013/12/08/babys-first-garbage-collector/" target="_blank" rel="external"> <strong>C</strong> 语言实现的 <strong>Garbage Collector</strong> </a></p>
<p>借着这个小程序顺便深入地了解一下Lua的垃圾回收机制</p>
<h2 id="Garbage-Collector算法小结"><a href="#Garbage-Collector算法小结" class="headerlink" title="Garbage Collector算法小结"></a>Garbage Collector算法小结</h2><p>这是之前做的一点小笔记：</p>
<p><img src="http://oe9uinblw.bkt.clouddn.com/WechatIMG1.jpeg" alt=""></p>
<h2 id="C-Garbage-Collector"><a href="#C-Garbage-Collector" class="headerlink" title="C Garbage Collector"></a>C Garbage Collector</h2><p>首先还是先来看看这个 <strong>C</strong> 的基本的垃圾回收器</p>
<h3 id="采用的算法"><a href="#采用的算法" class="headerlink" title="采用的算法"></a>采用的算法</h3><p>用的是经典的 <strong>Mark &amp; Sweep</strong> 算法</p>
<p>在上面的笔记里面已经介绍的很清楚了</p>
<p>该算法的工作原理几乎与我们对 <strong>可访问性(reachability)</strong> 的定义完全一样：</p>
<ol>
<li><p>从根节点开始，依次遍历整个对象图。每当你访问到一个对象，在上面设置一个 标记(mark) 位，置为 true 。</p>
</li>
<li><p>一旦搞定，找出所有标记位为 not 的对象集，然后删除它们。</p>
</li>
</ol>
<h3 id="对象对"><a href="#对象对" class="headerlink" title="对象对"></a>对象对</h3><p>要想清理垃圾，首先我们得制造点垃圾出来</p>
<p>所以假设我们正在为一种简单的语言编写一个解释器。它是动态的类型并且有两种类型的变量：<strong>int</strong> 和 <strong>pair</strong> 。 下面是用枚举来标示一个对象的类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// pair : 任何一对东西</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</div><div class="line">    OBJ_INT,</div><div class="line">    OBJ_PAIR</div><div class="line">&#125; ObjectType;</div><div class="line"></div><div class="line"><span class="comment">// 因为一个对象在虚拟机中可以是这两个当中的任意一种类型，所以在C中用tagged union 来实现对象</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> sObject &#123;</div><div class="line">    <span class="comment">//表示对象类型：pair or int</span></div><div class="line">    ObjectType type;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> marked;</div><div class="line"></div><div class="line">    <span class="comment">//仅维持一张由所有分配过(内存)的对象(组成)的链表。</span></div><div class="line">    <span class="keyword">struct</span> sObject*next;</div><div class="line"></div><div class="line">    <span class="comment">//union持有这个数据</span></div><div class="line">    <span class="comment">//union就是一个结构体，它将字段重叠在内存中</span></div><div class="line">    <span class="keyword">union</span> &#123;</div><div class="line">        <span class="keyword">int</span> value;</div><div class="line"></div><div class="line">        <span class="keyword">struct</span> &#123;</div><div class="line">            <span class="keyword">struct</span> sObject* head;</div><div class="line">            <span class="keyword">struct</span> sObject* tail;</div><div class="line">        &#125;;</div><div class="line">    &#125;;</div><div class="line">&#125; Object;</div></pre></td></tr></table></figure>
<hr>
<h3 id="小虚拟机"><a href="#小虚拟机" class="headerlink" title="小虚拟机"></a>小虚拟机</h3><p>虚拟机要么基于栈( <strong>JVM</strong> , <strong>CLR</strong> )，要么基于寄存器( <strong>Lua</strong> )，其实本质上说都是基于栈的，它用来保存一个表达式中间需要用到的临时变量和局部变量</p>
<p>下面我们建立一个简洁的虚拟机模型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 小虚拟机</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">    Object* <span class="built_in">stack</span>[STACK_MAX];</div><div class="line">    <span class="keyword">int</span> stackSize;</div><div class="line"></div><div class="line">    <span class="comment">//虚拟机会保留链表头的痕迹</span></div><div class="line">    Object* firstObject;</div><div class="line"></div><div class="line">    <span class="comment">//追踪创建了多少个对象</span></div><div class="line">    <span class="keyword">int</span> numObjects;</div><div class="line"></div><div class="line">    <span class="comment">//多少数目之后清理</span></div><div class="line">    <span class="keyword">int</span> maxObjects;</div><div class="line">&#125; VM;</div></pre></td></tr></table></figure>
<hr>
<h3 id="虚拟机的操作"><a href="#虚拟机的操作" class="headerlink" title="虚拟机的操作"></a>虚拟机的操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 初始化一个虚拟机</span></div><div class="line"><span class="function">VM* <span class="title">newVM</span><span class="params">()</span> </span>&#123;</div><div class="line">    VM* vm = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(VM));</div><div class="line">    vm-&gt;stackSize = <span class="number">0</span>;</div><div class="line">    Object* firstObject = <span class="literal">NULL</span>;</div><div class="line">    vm-&gt;numObjects = <span class="number">0</span>;</div><div class="line">    vm-&gt;maxObjects = <span class="number">8</span>;</div><div class="line">    <span class="keyword">return</span> vm;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//操作虚拟机堆栈</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(VM* vm, Object* value)</span> </span>&#123;</div><div class="line">    assert(vm-&gt;stackSize &lt; STACK_MAX, <span class="string">"Stack overflow!!!"</span>);</div><div class="line">    vm-&gt;<span class="built_in">stack</span>[vm-&gt;stackSize++] = value;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">Object* <span class="title">pop</span><span class="params">(VM* vm)</span> </span>&#123;</div><div class="line">    assert(vm-&gt;stackSize &gt; <span class="number">0</span>, <span class="string">"Stack underflow!!!"</span>);</div><div class="line">    <span class="keyword">return</span> vm-&gt;<span class="built_in">stack</span>[--vm-&gt;stackSize];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="Mark"><a href="#Mark" class="headerlink" title="Mark"></a>Mark</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">mark</span><span class="params">(Object* object)</span> </span>&#123;</div><div class="line">    <span class="comment">//检查循环!</span></div><div class="line">    <span class="keyword">if</span> (object-&gt;marked) <span class="keyword">return</span>;</div><div class="line">    object-&gt;marked = <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (object-&gt;type == OBJ_PAIR) &#123;</div><div class="line">        mark(object-&gt;head);</div><div class="line">        mark(object-&gt;tail);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">markAll</span><span class="params">(VM* vm)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vm-&gt;stackSize; i++) &#123;</div><div class="line">        mark(vm-&gt;<span class="built_in">stack</span>[i]);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="Sweep"><a href="#Sweep" class="headerlink" title="Sweep"></a>Sweep</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//清理</span></div><div class="line"><span class="comment">//仅维持一张由所有分配过(内存)的对象(组成)的链表。</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sweep</span><span class="params">(VM* vm)</span> </span>&#123;</div><div class="line">    Object** object = &amp;vm-&gt;firstObject;</div><div class="line">    <span class="keyword">while</span> (*object) &#123;</div><div class="line">        <span class="keyword">if</span> (!(*object)-&gt;marked) &#123;</div><div class="line">            <span class="comment">//没有访问过，所以从链表中移除然后释放它</span></div><div class="line">            Object* unreached = *object;</div><div class="line"></div><div class="line">            *object = unreached-&gt;next;</div><div class="line">            <span class="built_in">free</span>(unreached);</div><div class="line"></div><div class="line">            vm-&gt;numObjects--;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//访问过，所以不标记它</span></div><div class="line">            (*object)-&gt;marked = <span class="number">0</span>;</div><div class="line">            object = &amp;(*object)-&gt;next;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">gc</span><span class="params">(VM* vm)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> numObjects = vm-&gt;numObjects;</div><div class="line"></div><div class="line">    markAll(vm);</div><div class="line">    sweep(vm);</div><div class="line"></div><div class="line">    vm-&gt;maxObjects = vm-&gt;numObjects * <span class="number">2</span>;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Collected %d objects, %d remaining.\n"</span>, numObjects - vm-&gt;numObjects,</div><div class="line">            vm-&gt;numObjects);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="对象操作函数"><a href="#对象操作函数" class="headerlink" title="对象操作函数"></a>对象操作函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="function">Object* <span class="title">newObject</span><span class="params">(VM* vm, ObjectType type)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (vm-&gt;numObjects == vm-&gt;maxObjects) gc(vm);</div><div class="line"></div><div class="line">    Object* object = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Object));</div><div class="line">    object-&gt;type = type;</div><div class="line">    <span class="comment">//无论何时创建对象，都添加到链表中</span></div><div class="line">    object-&gt;next = vm-&gt;firstObject;</div><div class="line">    vm-&gt;firstObject = object;</div><div class="line">    object-&gt;marked = <span class="number">0</span>;</div><div class="line"></div><div class="line">    vm-&gt;numObjects++;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> object;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//编写方法将每种类型的对象压到虚拟机的栈上</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushInt</span><span class="params">(VM* vm, <span class="keyword">int</span> intValue)</span> </span>&#123;</div><div class="line">    Object* object = newObject(vm, OBJ_INT);</div><div class="line">    object-&gt;value = intValue;</div><div class="line">    </div><div class="line">    push(vm, object);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">Object* <span class="title">pushPair</span><span class="params">(VM* vm)</span> </span>&#123;</div><div class="line">    Object* object = newObject(vm, OBJ_PAIR);</div><div class="line">    object-&gt;tail = pop(vm);</div><div class="line">    object-&gt;head = pop(vm);</div><div class="line"></div><div class="line">    push(vm, object);</div><div class="line">    <span class="keyword">return</span> object;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">objectPrint</span><span class="params">(Object* object)</span> </span>&#123;</div><div class="line">    <span class="keyword">switch</span> (object-&gt;type) &#123;</div><div class="line">        <span class="keyword">case</span> OBJ_INT:</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, object-&gt;value);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="keyword">case</span> OBJ_PAIR:</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"("</span>);</div><div class="line">        objectPrint(object-&gt;head);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">", "</span>);</div><div class="line">        objectPrint(object-&gt;tail);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">")"</span>);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="free、test、main"><a href="#free、test、main" class="headerlink" title="free、test、main"></a>free、test、main</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeVM</span><span class="params">(VM  *vm)</span> </span>&#123;</div><div class="line">    vm-&gt;stackSize = <span class="number">0</span>;</div><div class="line">    gc(vm);</div><div class="line">    <span class="built_in">free</span>(vm);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Test1: Objects on stack are preserved.\n"</span>);</div><div class="line">    VM* vm = newVM();</div><div class="line">    pushInt(vm, <span class="number">1</span>);</div><div class="line">    pushInt(vm, <span class="number">2</span>);</div><div class="line"></div><div class="line">    gc(vm);</div><div class="line">    assert(vm-&gt;numObjects == <span class="number">2</span>, <span class="string">"Should have preserved objects."</span>);</div><div class="line">    freeVM(vm);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Test2: Objects on stack are collected.\n"</span>);</div><div class="line">    VM* vm = newVM();</div><div class="line">    pushInt(vm, <span class="number">1</span>);</div><div class="line">    pushInt(vm, <span class="number">2</span>);</div><div class="line">    pop(vm);</div><div class="line">    pop(vm);</div><div class="line"></div><div class="line">    gc(vm);</div><div class="line">    assert(vm-&gt;numObjects == <span class="number">0</span>, <span class="string">"Should have collected objects."</span>);</div><div class="line">    freeVM(vm);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Test3: Reach nested objects.\n"</span>);</div><div class="line">    VM* vm = newVM();</div><div class="line">    pushInt(vm, <span class="number">1</span>);</div><div class="line">    pushInt(vm, <span class="number">2</span>);</div><div class="line">    pushPair(vm);</div><div class="line">    pushInt(vm, <span class="number">3</span>);</div><div class="line">    pushInt(vm, <span class="number">4</span>);</div><div class="line">    pushPair(vm);</div><div class="line">    pushPair(vm);</div><div class="line"></div><div class="line">    gc(vm);</div><div class="line">    assert(vm-&gt;numObjects == <span class="number">7</span>, <span class="string">"Should have reached objects."</span>);</div><div class="line">    freeVM(vm);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Test4: Handle cycles.\n"</span>);</div><div class="line">    VM* vm = newVM();</div><div class="line">    pushInt(vm, <span class="number">1</span>);</div><div class="line">    pushInt(vm, <span class="number">2</span>);</div><div class="line">    Object* a = pushPair(vm);</div><div class="line">    pushInt(vm, <span class="number">3</span>);</div><div class="line">    pushInt(vm, <span class="number">4</span>);</div><div class="line">    Object* b = pushPair(vm);</div><div class="line"></div><div class="line">    <span class="comment">//建立一个循环， 并且让2 和 4 不可到达和收集</span></div><div class="line">    a-&gt;tail = b;</div><div class="line">    b-&gt;tail = a;</div><div class="line"></div><div class="line">    gc(vm);</div><div class="line">    assert(vm-&gt;numObjects == <span class="number">4</span>, <span class="string">"Should have collected objects."</span>);</div><div class="line">    freeVM(vm);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">perfTest</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Performance Tset\n"</span>);</div><div class="line">    VM* vm = newVM();</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">20</span>; j++) &#123;</div><div class="line">            pushInt(vm, i);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">20</span>; k++) &#123;</div><div class="line">            pop(vm);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    freeVM(vm);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</div><div class="line">    test1();</div><div class="line">    test2();</div><div class="line">    test3();</div><div class="line">    test4();</div><div class="line">    perfTest();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><p><img src="http://oe9uinblw.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-14%2015.20.31.png" alt=""></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这个简单的收集器与目前 <strong>Ruby</strong> 和 <strong>Lua</strong> 中的收集器非常的相似，所以下一次我们将深入了解 <strong>Lua</strong> 的 <strong>GC</strong> 机制。</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/04/13/深入 Lua Garbage Collector(一)/" class="archive-article-date">
  	<time datetime="2017-04-13T01:54:34.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-04-13</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/gc/">gc</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/lua/">lua</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="airticle-Linux下的轻量服务器实现" class="article article-type-airticle" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/31/Linux下的轻量服务器实现/">Linux下的的轻量级HTTP服务器实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p></p><p></p>
<h2 id="小型HTTP服务器"><a href="#小型HTTP服务器" class="headerlink" title="小型HTTP服务器"></a>小型HTTP服务器</h2><p>读了很多 <strong>Linux</strong> 下小型的 <strong>http</strong> 服务器，还是觉得来自<a href="http://www.jianshu.com/p/912fa6d0b5e0" target="_blank" rel="external">朱家顺的Zaver</a>比较适合新手学习</p>
<blockquote>
<p>Zaver，一个结构简单，支持高并发的http服务器。基本架构是事件循环 + non-blocking I/O + 线程池。Zaver的代码风格参考了Nginx的风格，所以在可读性上非常高。另外，Zaver提供了配置文件和命令行参数解析，以及完善的Makefile和源代码结构，也可以帮助任何一个C初学者入门一个项目是怎么构建的。</p>
</blockquote>
<hr>
<h2 id="需要改进的地方"><a href="#需要改进的地方" class="headerlink" title="需要改进的地方"></a>需要改进的地方</h2><ul>
<li>只支持静态页面</li>
<li>HTTP1.1支持不完全，目前只实现了几个主要的（keep-alive, browser cache）的header解析</li>
<li>没有内存池</li>
<li>没有缓存</li>
<li>没有日志</li>
<li>没有用session建立对话</li>
<li>无活动连接的超时过期还没有做</li>
<li>后台运行用的是 <em>while死循环</em> 而不是 <em> daemon process </em> </li>
</ul>
<hr>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>主要还是体会一下，毕竟刚接触网络编程，顺便复习一下知识点</p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>使用一个文件描述符管理多个描述符，把事件都放入一个时间表中</p>
<ul>
<li>int epoll_create();</li>
<li>int epoll_ctl();</li>
<li>int epoll_wait();</li>
</ul>
<p>如果一个fd没有被它的工作线程读完，所以依然会被认为是可读的，如果下次事件循环又返回这个fd，又会分给别的线程。<br>所以要将默认的LT（level trigger）水平触发改为ET（edge trigger）边缘触发模式</p>
<p>更多关于select poll epoll的学习可以看<a href="http://www.cnblogs.com/Anker/p/3258674.html" target="_blank" rel="external">这个大神的博客</a></p>
<hr>
<h3 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h3><p>自定义调试信息的输出</p>
<blockquote>
<p>调试信息的输出方法有很多种,  例如直接用printf,  或者出错时使用perror, fprintf等将信息直接打印到终端上, 在Qt上面一般使用qDebug，而守护进程则一般是使用syslog将调试信息输出到日志文件中等等…</p>
<p>使用标准的方法打印调试信息有时候不是很方便,  例如Qt编程, 在调试已有的代码时, 我想在打印调试信息的地方, 把代码位置也打印出来以方便定位错误, 或者需要在调试信息前面加一个前辍, 好方便在调试信息太多的时候可以用grep过滤一下, 仅显示本模块的调试信息, 这时就需要一个一个地修改已有的qDebug, 使其成为以下形式:<br>　　<br>qDebug( “[模块名称] 调试信息  File:%s, Line:%d”, <strong>FILE</strong>, <strong>LINE</strong> );<br>　　<br>这样的修改比较烦人, 而且一不小心会遗漏某个没改的…<br>为了能方便地管理调试信息的输出，一个比较简单的方法就是自已定义一个打印调试信息的宏, 然后替换原来的，废话就不多说了，直接给出一个现成的，下面是一个例子, 我用WiFi表示当前代码的模块名称，我要求在模块中的所有调试信息前面均带有[WiFi]前辍，这样我就能方便地只需使用命令行 | grep “[WiFi]“来过滤掉来自其它模块的调试信息了:</p>
<p>#define qWiFiDebug(format, …) qDebug(“[WiFi] “format” File:%s, Line:%d, Function:%s”, ##<strong>VA_ARGS</strong>, <strong>FILE</strong>, <strong>LINE</strong> , <strong>FUNCTION</strong>);<br>　　<br>上面的宏是使用qDebug输出调试信息，在非Qt的程序中也可以改为printf，守护进程则可以改为syslog等等…  其中，决窍其实就是这几个宏 ##<strong>VA_ARGS</strong>, <strong>FILE</strong>, <strong>LINE</strong> 和<strong>FUNCTION</strong>,下面介绍一下这几个宏:<br>　　1)  <strong>VA_ARGS</strong> 是一个可变参数的宏，很少人知道这个宏，这个可变参数的宏是新的C99规范中新增的，目前似乎只有gcc支持（VC6.0的编译器不支持）。宏前面加上##的作用在于，当可变参数的个数为0时，这里的##起到把前面多余的”,”去掉的作用,否则会编译出错, 你可以试试。<br>　　2) <strong>FILE</strong> 宏在预编译时会替换成当前的源文件名<br>　　3) <strong>LINE</strong>宏在预编译时会替换成当前的行号<br>　　4) <strong>FUNCTION</strong>宏在预编译时会替换成当前的函数名称<br>　　有了以上这几个宏，特别是有了<strong>VA_ARGS</strong> ，调试信息的输出就变得灵活多了。</p>
</blockquote>
<hr>
<h3 id="threadpool"><a href="#threadpool" class="headerlink" title="threadpool"></a>threadpool</h3><p>用C++来实现线程池，之前也写过<a href="https://github.com/lizhenghn123/zl_threadpool" target="_blank" rel="external">这个大神的C++的线程池demo</a>，分别用C++98、C++03、C++11实现了一遍，体会到C++11的方便了啊</p>
<p>因为项目是C语言的，所以必须用到 <em> extern关键字 </em> 来混入C++代码，这也是面试常考的内容</p>
<p>具体的看这篇博文<a href="http://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777431.html" target="_blank" rel="external">C/C++中extern关键字详解</a></p>
<p>线程池主要含有三个队列</p>
<ul>
<li>工作队列</li>
<li>工作线程队列</li>
<li>忙碌线程队列</li>
</ul>
<hr>
<h3 id="timer"><a href="#timer" class="headerlink" title="timer"></a>timer</h3><p><strong>Nginx</strong> 用 <strong>rbtree</strong> 实现timer</p>
<p>但是为了简单化，我们用 <strong>libevent</strong> 的 <strong>2-heap</strong> 二叉最小堆来实现</p>
<blockquote>
<p>淘宝的 <strong>Tengine</strong> 用 <strong>4-heap</strong> 四叉最小堆实现 timer ，四叉最小堆是二叉最小堆的变种，比其有更浅的深度和更好的 <strong>CPU Cache</strong> 命中率</p>
</blockquote>
<h3 id="http"><a href="#http" class="headerlink" title="http"></a>http</h3><p>1.method</p>
<blockquote>
<p>nginx在判断http method的时候用的不是字符串比较，而是整数比较。<br>比如“POST”，一般的写法是用strcmp，就会牵扯到4次char的比较。<br>而nginx把接受到的method转化为一个int，那么4次比较就可以转化为1次比较。</p>
</blockquote>
<p>具体代码如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_str3Ocmp(m, c0, c1, c2, c3)                                     \</span></div><div class="line">    *(uint32_t *) m == ((c3 <span class="meta-string">&lt;&lt; 24) | (c2 &lt;&lt; 16) | (c1 &lt;&lt; 8) | c0)</span></div></pre></td></tr></table></figure>
<hr>
<p>2.request</p>
<ul>
<li>参考Nginx，用priority queue来存储header</li>
<li><a href="http://blog.csdn.net/stevenliyong/article/details/4160181" target="_blank" rel="external">关于__GNU_SOURCE这个宏</a></li>
<li><a href="http://stackoverflow.com/questions/20222079/epoll-wait-returning-events-on-closed-file-descriptor" target="_blank" rel="external">关于epoll的小细节</a></li>
</ul>
<p>3.parse</p>
<p>目前只实现了几个主要的（keep-alive, browser cache）的header解析</p>
<p>4.connection</p>
<p>这一部分的实现放在了utils里面</p>
<h3 id="utility各种通用函数"><a href="#utility各种通用函数" class="headerlink" title="utility各种通用函数"></a>utility各种通用函数</h3><p>这里主要是connect的函数</p>
<p>话说C的模块化真是一门技术活，全靠文件。。。</p>
<h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><h2 id="搭建成功"><a href="#搭建成功" class="headerlink" title="搭建成功"></a>搭建成功</h2><p><img src="http://oe9uinblw.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-09%2003.36.45.png" alt=""></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/03/31/Linux下的轻量服务器实现/" class="archive-article-date">
  	<time datetime="2017-03-31T03:53:23.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-03-31</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http/">http</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/">nginx</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/web-server/">web server</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="airticle-C++11 并发学习(四)" class="article article-type-airticle" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/15/C++11 并发学习(四)/">C++11 并发学习(四)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p></p><p><br><a href="http://www.cnblogs.com/haippy/p/3284540.html" target="_blank" rel="external">学习自大神博客</a></p>
<h2 id="下面我们来看一下C-11多线程下生产者消费者模型"><a href="#下面我们来看一下C-11多线程下生产者消费者模型" class="headerlink" title="下面我们来看一下C++11多线程下生产者消费者模型"></a>下面我们来看一下C++11多线程下生产者消费者模型</h2><h3 id="单生产者-单消费者模型"><a href="#单生产者-单消费者模型" class="headerlink" title="单生产者-单消费者模型"></a>单生产者-单消费者模型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kItemRepositorySize = <span class="number">10</span>;  <span class="comment">//Item buffer size</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kItemsToProduce = <span class="number">100</span>; <span class="comment">//How many items we plan to produce</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> ItemRepository &#123;</div><div class="line">    <span class="keyword">int</span> item_buffer[kItemRepositorySize]; <span class="comment">//产品缓冲区， 配合模拟环形队列</span></div><div class="line">    <span class="keyword">size_t</span> read_position; <span class="comment">//消费者读取产品位置</span></div><div class="line">    <span class="keyword">size_t</span> write_position; <span class="comment">//生产者写入产品位置</span></div><div class="line">    <span class="built_in">std</span>::mutex mtx; <span class="comment">//互斥量，保护产品缓冲区</span></div><div class="line">    <span class="built_in">std</span>::condition_variable repo_not_full; <span class="comment">//条件变量，指示产品缓冲区不为满</span></div><div class="line">    <span class="built_in">std</span>::condition_variable repo_not_empty; <span class="comment">//条件变量，指示产品缓冲区不为空</span></div><div class="line">&#125; gItemRepository; <span class="comment">//产品库全局变量，生产者和消费者操作该变量</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> ItemRepository ItemRepository;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProduceItem</span><span class="params">(ItemRepository *ir, <span class="keyword">int</span> item)</span> </span>&#123;</div><div class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(ir-&gt;mtx);</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (((ir-&gt;write_position + <span class="number">1</span>) % kItemRepositorySize) == ir-&gt;read_position) &#123;</div><div class="line">        <span class="comment">//buffer is full</span></div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Producer is waiting for an empty slot...\n"</span>;</div><div class="line">        (ir-&gt;repo_not_full).wait(lock); <span class="comment">//生产者等待"产品库缓冲区不为满"这一条件发生</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    (ir-&gt;item_buffer)[ir-&gt;write_position] = item; <span class="comment">//写入产品</span></div><div class="line">    (ir-&gt;write_position)++; <span class="comment">//写入位置后移</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (ir-&gt;write_position == kItemRepositorySize) &#123;</div><div class="line">        <span class="comment">//写入位置如果在队列最后 则需要重新设置为初始位置</span></div><div class="line">        ir-&gt;write_position = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    (ir-&gt;repo_not_empty).notify_all(); <span class="comment">//通知消费者产品库不为空</span></div><div class="line">    lock.unlock();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ConsumeItem</span><span class="params">(ItemRepository *ir)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> data;</div><div class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(ir-&gt;mtx);</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (ir-&gt;write_position == ir-&gt;read_position) &#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Consumer is waiting for items...\n"</span>;</div><div class="line">        (ir-&gt;repo_not_empty).wait(lock); <span class="comment">// 消费者等待"产品库缓冲区不为空"这一条件发生</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    data = (ir-&gt;item_buffer)[ir-&gt;read_position]; <span class="comment">//读取产品</span></div><div class="line">    (ir-&gt;read_position)++; <span class="comment">//读取位置后移</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (ir-&gt;read_position &gt;= kItemRepositorySize) &#123;</div><div class="line">        <span class="comment">//读取位置如果在队列最后 则需要重新设置为初始位置</span></div><div class="line">        ir-&gt;read_position = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    (ir-&gt;repo_not_full).notify_all();</div><div class="line">    lock.unlock();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> data;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//生产者任务</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProducerTask</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; kItemsToProduce; ++i) &#123;</div><div class="line">        <span class="comment">//sleep(1);</span></div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Produce the"</span> &lt;&lt; i &lt;&lt; <span class="string">"^th item..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">        ProduceItem(&amp;gItemRepository, i); <span class="comment">//循环生产 kItemsToProduce 个产品</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//消费者任务</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConsumerTask</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</div><div class="line">        sleep(<span class="number">1</span>);</div><div class="line">        <span class="keyword">int</span> item = ConsumeItem(&amp;gItemRepository); <span class="comment">//消费一个产品</span></div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Consume the"</span> &lt;&lt; item &lt;&lt; <span class="string">"^th item"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">        <span class="keyword">if</span> (++cnt == kItemsToProduce) &#123;</div><div class="line">            <span class="comment">//如果产品消费个数为 kItemsToProduce, 则退出.</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitItemRepository</span><span class="params">(ItemRepository *ir)</span> </span>&#123;</div><div class="line">    ir-&gt;write_position = <span class="number">0</span>;</div><div class="line">    ir-&gt;read_position = <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    InitItemRepository(&amp;gItemRepository);</div><div class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">producer</span><span class="params">(ProducerTask)</span></span>;</div><div class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">consumer</span><span class="params">(ConsumerTask)</span></span>;</div><div class="line">    producer.join();</div><div class="line">    consumer.join();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>运行结果：</p>
<p><img src="http://oe9uinblw.bkt.clouddn.com/C++%E5%B9%B6%E5%8F%911.png" alt=""></p>
<hr>
<h2 id="单生产者-多消费者模型"><a href="#单生产者-多消费者模型" class="headerlink" title="单生产者-多消费者模型"></a>单生产者-多消费者模型</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//与单生产者和单消费者模型不同的是，</span></div><div class="line"><span class="comment">//单生产者-多消费者模型中可以允许多个消费者同时从产品库中取走产品。</span></div><div class="line"><span class="comment">//所以除了保护产品库在多个读写线程下互斥之外，还需要维护消费者取走产品的计数器</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kItemRepositorySize = <span class="number">10</span>;  <span class="comment">//Item buffer size</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kItemsToProduce = <span class="number">100</span>; <span class="comment">//How many items we plan to produce</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> ItemRepository &#123;</div><div class="line">    <span class="keyword">int</span> item_buffer[kItemRepositorySize]; <span class="comment">//产品缓冲区， 配合模拟环形队列</span></div><div class="line">    <span class="keyword">size_t</span> read_position; <span class="comment">//消费者读取产品位置</span></div><div class="line">    <span class="keyword">size_t</span> write_position; <span class="comment">//生产者写入产品位置</span></div><div class="line">    </div><div class="line">    <span class="keyword">size_t</span> item_counter;</div><div class="line">    <span class="built_in">std</span>::mutex item_counter_mtx;</div><div class="line">    </div><div class="line">    <span class="built_in">std</span>::mutex mtx; <span class="comment">//互斥量，保护产品缓冲区</span></div><div class="line">    <span class="built_in">std</span>::condition_variable repo_not_full; <span class="comment">//条件变量，指示产品缓冲区不为满</span></div><div class="line">    <span class="built_in">std</span>::condition_variable repo_not_empty; <span class="comment">//条件变量，指示产品缓冲区不为空</span></div><div class="line">&#125; gItemRepository; <span class="comment">//产品库全局变量，生产者和消费者操作该变量</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> ItemRepository ItemRepository;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProduceItem</span><span class="params">(ItemRepository *ir, <span class="keyword">int</span> item)</span> </span>&#123;</div><div class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(ir-&gt;mtx);</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (((ir-&gt;write_position + <span class="number">1</span>) % kItemRepositorySize) == ir-&gt;read_position) &#123;</div><div class="line">        <span class="comment">//buffer is full</span></div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Producer is waiting for an empty slot...\n"</span>;</div><div class="line">        (ir-&gt;repo_not_full).wait(lock); <span class="comment">//生产者等待"产品库缓冲区不为满"这一条件发生</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    (ir-&gt;item_buffer)[ir-&gt;write_position] = item; <span class="comment">//写入产品</span></div><div class="line">    (ir-&gt;write_position)++; <span class="comment">//写入位置后移</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (ir-&gt;write_position == kItemRepositorySize) &#123;</div><div class="line">        <span class="comment">//写入位置如果在队列最后 则需要重新设置为初始位置</span></div><div class="line">        ir-&gt;write_position = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    (ir-&gt;repo_not_empty).notify_all(); <span class="comment">//通知消费者产品库不为空</span></div><div class="line">    lock.unlock();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ConsumeItem</span><span class="params">(ItemRepository *ir)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> data;</div><div class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(ir-&gt;mtx);</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (ir-&gt;write_position == ir-&gt;read_position) &#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Consumer is waiting for items...\n"</span>;</div><div class="line">        (ir-&gt;repo_not_empty).wait(lock); <span class="comment">// 消费者等待"产品库缓冲区不为空"这一条件发生</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    data = (ir-&gt;item_buffer)[ir-&gt;read_position]; <span class="comment">//读取产品</span></div><div class="line">    (ir-&gt;read_position)++; <span class="comment">//读取位置后移</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (ir-&gt;read_position &gt;= kItemRepositorySize) &#123;</div><div class="line">        <span class="comment">//读取位置如果在队列最后 则需要重新设置为初始位置</span></div><div class="line">        ir-&gt;read_position = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    (ir-&gt;repo_not_full).notify_all();</div><div class="line">    lock.unlock();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> data;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//生产者任务</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProducerTask</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; kItemsToProduce; ++i) &#123;</div><div class="line">        <span class="comment">//sleep(1);</span></div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Producer thread"</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">"Produce the"</span> &lt;&lt; i &lt;&lt; <span class="string">"^th item..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">        ProduceItem(&amp;gItemRepository, i); <span class="comment">//循环生产 kItemsToProduce 个产品</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Producer thread"</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">"is exiting..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//消费者任务</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConsumerTask</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">bool</span> ready_to_exit = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</div><div class="line">        sleep(<span class="number">1</span>);</div><div class="line">        <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(gItemRepository.item_counter_mtx);</div><div class="line">        <span class="keyword">if</span> (gItemRepository.item_counter &lt; kItemsToProduce) &#123;</div><div class="line">            <span class="keyword">int</span> item = ConsumeItem(&amp;gItemRepository);</div><div class="line">            ++(gItemRepository.item_counter);</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Consumer thread"</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">"is consuming the"</span> &lt;&lt; item &lt;&lt; <span class="string">"^th item"</span>&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">        &#125; <span class="keyword">else</span> ready_to_exit = <span class="literal">true</span>;</div><div class="line">        lock.unlock();</div><div class="line">        <span class="keyword">if</span> (ready_to_exit == <span class="literal">true</span>) &#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Consumer thread"</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">"is exiting..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitItemRepository</span><span class="params">(ItemRepository *ir)</span> </span>&#123;</div><div class="line">    ir-&gt;write_position = <span class="number">0</span>;</div><div class="line">    ir-&gt;read_position = <span class="number">0</span>;</div><div class="line">    ir-&gt;item_counter = <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    InitItemRepository(&amp;gItemRepository);</div><div class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">producer</span><span class="params">(ProducerTask)</span></span>;</div><div class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">consumer1</span><span class="params">(ConsumerTask)</span></span>;</div><div class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">consumer2</span><span class="params">(ConsumerTask)</span></span>;</div><div class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">consumer3</span><span class="params">(ConsumerTask)</span></span>;</div><div class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">consumer4</span><span class="params">(ConsumerTask)</span></span>;</div><div class="line">    producer.join();</div><div class="line">    consumer1.join();</div><div class="line">    consumer2.join();</div><div class="line">    consumer3.join();</div><div class="line">    consumer4.join();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>运行结果：</p>
<p><img src="http://oe9uinblw.bkt.clouddn.com/C++%E5%B9%B6%E5%8F%912.png" alt=""></p>
<hr>
<h2 id="多生产者-单消费者模型"><a href="#多生产者-单消费者模型" class="headerlink" title="多生产者-单消费者模型"></a>多生产者-单消费者模型</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//与单生产者和单消费者模型不同的是，</span></div><div class="line"><span class="comment">//单生产者-多消费者模型中可以允许多个消费者同时从产品库中取走产品。</span></div><div class="line"><span class="comment">//所以除了保护产品库在多个读写线程下互斥之外，还需要维护生产者放入产品的计数器</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kItemRepositorySize = <span class="number">10</span>;  <span class="comment">//Item buffer size</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kItemsToProduce = <span class="number">100</span>; <span class="comment">//How many items we plan to produce</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> ItemRepository &#123;</div><div class="line">    <span class="keyword">int</span> item_buffer[kItemRepositorySize]; <span class="comment">//产品缓冲区， 配合模拟环形队列</span></div><div class="line">    <span class="keyword">size_t</span> read_position; <span class="comment">//消费者读取产品位置</span></div><div class="line">    <span class="keyword">size_t</span> write_position; <span class="comment">//生产者写入产品位置</span></div><div class="line">    </div><div class="line">    <span class="keyword">size_t</span> item_counter;</div><div class="line">    <span class="built_in">std</span>::mutex item_counter_mtx;</div><div class="line">    </div><div class="line">    <span class="built_in">std</span>::mutex mtx; <span class="comment">//互斥量，保护产品缓冲区</span></div><div class="line">    <span class="built_in">std</span>::condition_variable repo_not_full; <span class="comment">//条件变量，指示产品缓冲区不为满</span></div><div class="line">    <span class="built_in">std</span>::condition_variable repo_not_empty; <span class="comment">//条件变量，指示产品缓冲区不为空</span></div><div class="line">&#125; gItemRepository; <span class="comment">//产品库全局变量，生产者和消费者操作该变量</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> ItemRepository ItemRepository;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProduceItem</span><span class="params">(ItemRepository *ir, <span class="keyword">int</span> item)</span> </span>&#123;</div><div class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(ir-&gt;mtx);</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (((ir-&gt;write_position + <span class="number">1</span>) % kItemRepositorySize) == ir-&gt;read_position) &#123;</div><div class="line">        <span class="comment">//buffer is full</span></div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Producer is waiting for an empty slot...\n"</span>;</div><div class="line">        (ir-&gt;repo_not_full).wait(lock); <span class="comment">//生产者等待"产品库缓冲区不为满"这一条件发生</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    (ir-&gt;item_buffer)[ir-&gt;write_position] = item; <span class="comment">//写入产品</span></div><div class="line">    (ir-&gt;write_position)++; <span class="comment">//写入位置后移</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (ir-&gt;write_position == kItemRepositorySize) &#123;</div><div class="line">        <span class="comment">//写入位置如果在队列最后 则需要重新设置为初始位置</span></div><div class="line">        ir-&gt;write_position = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    (ir-&gt;repo_not_empty).notify_all(); <span class="comment">//通知消费者产品库不为空</span></div><div class="line">    lock.unlock();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ConsumeItem</span><span class="params">(ItemRepository *ir)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> data;</div><div class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(ir-&gt;mtx);</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (ir-&gt;write_position == ir-&gt;read_position) &#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Consumer is waiting for items...\n"</span>;</div><div class="line">        (ir-&gt;repo_not_empty).wait(lock); <span class="comment">// 消费者等待"产品库缓冲区不为空"这一条件发生</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    data = (ir-&gt;item_buffer)[ir-&gt;read_position]; <span class="comment">//读取产品</span></div><div class="line">    (ir-&gt;read_position)++; <span class="comment">//读取位置后移</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (ir-&gt;read_position &gt;= kItemRepositorySize) &#123;</div><div class="line">        <span class="comment">//读取位置如果在队列最后 则需要重新设置为初始位置</span></div><div class="line">        ir-&gt;read_position = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    (ir-&gt;repo_not_full).notify_all();</div><div class="line">    lock.unlock();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> data;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//生产者任务</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProducerTask</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">bool</span> ready_to_exit = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">        sleep(<span class="number">1</span>);</div><div class="line">        <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(gItemRepository.item_counter_mtx);</div><div class="line">        <span class="keyword">if</span> (gItemRepository.item_counter &lt; kItemsToProduce) &#123;</div><div class="line">            ++(gItemRepository.item_counter);</div><div class="line">            ProduceItem(&amp;gItemRepository, gItemRepository.item_counter);</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Producer thread"</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">"is producing the"</span> &lt;&lt; gItemRepository.item_counter &lt;&lt; <span class="string">"^th item..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">        &#125; <span class="keyword">else</span> ready_to_exit = <span class="literal">true</span>;</div><div class="line">        lock.unlock();</div><div class="line">        <span class="keyword">if</span> (ready_to_exit == <span class="literal">true</span>) &#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Producer thread"</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">"is exiting..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//消费者任务</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConsumerTask</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> item_consumed = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">        sleep(<span class="number">1</span>);</div><div class="line">        ++item_consumed;</div><div class="line">        <span class="keyword">if</span> (item_consumed &lt;= kItemsToProduce) &#123;</div><div class="line">            <span class="keyword">int</span> item = ConsumeItem(&amp;gItemRepository);</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Consumer thread"</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">"is consuming the"</span> &lt;&lt; item &lt;&lt; <span class="string">"^th item"</span>&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;   </div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Consumer thread"</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">"is exiting..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitItemRepository</span><span class="params">(ItemRepository *ir)</span> </span>&#123;</div><div class="line">    ir-&gt;write_position = <span class="number">0</span>;</div><div class="line">    ir-&gt;read_position = <span class="number">0</span>;</div><div class="line">    ir-&gt;item_counter = <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    InitItemRepository(&amp;gItemRepository);</div><div class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">producer1</span><span class="params">(ProducerTask)</span></span>;</div><div class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">producer2</span><span class="params">(ProducerTask)</span></span>;</div><div class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">producer3</span><span class="params">(ProducerTask)</span></span>;</div><div class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">producer4</span><span class="params">(ProducerTask)</span></span>;</div><div class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">consumer</span><span class="params">(ConsumerTask)</span></span>;</div><div class="line">    producer1.join();</div><div class="line">    producer2.join();</div><div class="line">    producer3.join();</div><div class="line">    producer4.join();</div><div class="line">    consumer.join();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>运行结果：</p>
<p><img src="http://oe9uinblw.bkt.clouddn.com/C++%E5%B9%B6%E5%8F%913.png" alt=""></p>
<hr>
<h2 id="多生产者-多消费者模型"><a href="#多生产者-多消费者模型" class="headerlink" title="多生产者-多消费者模型"></a>多生产者-多消费者模型</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//该模型可以说是前面两种模型的综合，程序需要维护两个计数器，</span></div><div class="line"><span class="comment">//分别是生产者已生产产品的数目和消费者已取走产品的数目。</span></div><div class="line"><span class="comment">//另外也需要保护产品库在多个生产者和多个消费者互斥地访问</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kItemRepositorySize = <span class="number">10</span>;  <span class="comment">//Item buffer size</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kItemsToProduce = <span class="number">100</span>; <span class="comment">//How many items we plan to produce</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> ItemRepository &#123;</div><div class="line">    <span class="keyword">int</span> item_buffer[kItemRepositorySize]; <span class="comment">//产品缓冲区， 配合模拟环形队列</span></div><div class="line">    <span class="keyword">size_t</span> read_position; <span class="comment">//消费者读取产品位置</span></div><div class="line">    <span class="keyword">size_t</span> write_position; <span class="comment">//生产者写入产品位置</span></div><div class="line">    </div><div class="line">    <span class="keyword">size_t</span> produced_item_counter;</div><div class="line">    <span class="keyword">size_t</span> consumed_item_counter;</div><div class="line"></div><div class="line">    <span class="built_in">std</span>::mutex produced_item_counter_mtx;</div><div class="line">    <span class="built_in">std</span>::mutex consumed_item_counter_mtx;</div><div class="line">    </div><div class="line">    <span class="built_in">std</span>::mutex mtx; <span class="comment">//互斥量，保护产品缓冲区</span></div><div class="line">    <span class="built_in">std</span>::condition_variable repo_not_full; <span class="comment">//条件变量，指示产品缓冲区不为满</span></div><div class="line">    <span class="built_in">std</span>::condition_variable repo_not_empty; <span class="comment">//条件变量，指示产品缓冲区不为空</span></div><div class="line">&#125; gItemRepository; <span class="comment">//产品库全局变量，生产者和消费者操作该变量</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> ItemRepository ItemRepository;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProduceItem</span><span class="params">(ItemRepository *ir, <span class="keyword">int</span> item)</span> </span>&#123;</div><div class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(ir-&gt;mtx);</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (((ir-&gt;write_position + <span class="number">1</span>) % kItemRepositorySize) == ir-&gt;read_position) &#123;</div><div class="line">        <span class="comment">//buffer is full</span></div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Producer is waiting for an empty slot...\n"</span>;</div><div class="line">        (ir-&gt;repo_not_full).wait(lock); <span class="comment">//生产者等待"产品库缓冲区不为满"这一条件发生</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    (ir-&gt;item_buffer)[ir-&gt;write_position] = item; <span class="comment">//写入产品</span></div><div class="line">    (ir-&gt;write_position)++; <span class="comment">//写入位置后移</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (ir-&gt;write_position == kItemRepositorySize) &#123;</div><div class="line">        <span class="comment">//写入位置如果在队列最后 则需要重新设置为初始位置</span></div><div class="line">        ir-&gt;write_position = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    (ir-&gt;repo_not_empty).notify_all(); <span class="comment">//通知消费者产品库不为空</span></div><div class="line">    lock.unlock();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ConsumeItem</span><span class="params">(ItemRepository *ir)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> data;</div><div class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(ir-&gt;mtx);</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (ir-&gt;write_position == ir-&gt;read_position) &#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Consumer is waiting for items...\n"</span>;</div><div class="line">        (ir-&gt;repo_not_empty).wait(lock); <span class="comment">// 消费者等待"产品库缓冲区不为空"这一条件发生</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    data = (ir-&gt;item_buffer)[ir-&gt;read_position]; <span class="comment">//读取产品</span></div><div class="line">    (ir-&gt;read_position)++; <span class="comment">//读取位置后移</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (ir-&gt;read_position &gt;= kItemRepositorySize) &#123;</div><div class="line">        <span class="comment">//读取位置如果在队列最后 则需要重新设置为初始位置</span></div><div class="line">        ir-&gt;read_position = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    (ir-&gt;repo_not_full).notify_all();</div><div class="line">    lock.unlock();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> data;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//生产者任务</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProducerTask</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">bool</span> ready_to_exit = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">        sleep(<span class="number">1</span>);</div><div class="line">        <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(gItemRepository.produced_item_counter_mtx);</div><div class="line">        <span class="keyword">if</span> (gItemRepository.produced_item_counter &lt; kItemsToProduce) &#123;</div><div class="line">            ++(gItemRepository.produced_item_counter);</div><div class="line">            ProduceItem(&amp;gItemRepository, gItemRepository.produced_item_counter);</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Producer thread"</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">"is producing the"</span> &lt;&lt; gItemRepository.produced_item_counter &lt;&lt; <span class="string">"^th item..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">        &#125; <span class="keyword">else</span> ready_to_exit = <span class="literal">true</span>;</div><div class="line">        lock.unlock();</div><div class="line">        <span class="keyword">if</span> (ready_to_exit == <span class="literal">true</span>) &#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Producer thread"</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">"is exiting..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//消费者任务</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConsumerTask</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">bool</span> ready_to_exit = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">        sleep(<span class="number">1</span>);</div><div class="line">        <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(gItemRepository.consumed_item_counter_mtx);</div><div class="line">        <span class="keyword">if</span> (gItemRepository.consumed_item_counter &lt;= kItemsToProduce) &#123;</div><div class="line">            <span class="keyword">int</span> item = ConsumeItem(&amp;gItemRepository);</div><div class="line">            ++(gItemRepository.consumed_item_counter);</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Consumer thread"</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">"is consuming the"</span> &lt;&lt; gItemRepository.consumed_item_counter &lt;&lt; <span class="string">"^th item"</span>&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  </div><div class="line">        &#125; <span class="keyword">else</span> ready_to_exit = <span class="literal">true</span>;</div><div class="line">        lock.unlock();</div><div class="line">        <span class="keyword">if</span> (ready_to_exit == <span class="literal">true</span>) &#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Consumer thread"</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">"is exiting..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitItemRepository</span><span class="params">(ItemRepository *ir)</span> </span>&#123;</div><div class="line">    ir-&gt;write_position = <span class="number">0</span>;</div><div class="line">    ir-&gt;read_position = <span class="number">0</span>;</div><div class="line">    ir-&gt;produced_item_counter = <span class="number">0</span>;</div><div class="line">    ir-&gt;consumed_item_counter = <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    InitItemRepository(&amp;gItemRepository);</div><div class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">producer1</span><span class="params">(ProducerTask)</span></span>;</div><div class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">producer2</span><span class="params">(ProducerTask)</span></span>;</div><div class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">producer3</span><span class="params">(ProducerTask)</span></span>;</div><div class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">producer4</span><span class="params">(ProducerTask)</span></span>;</div><div class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">consumer1</span><span class="params">(ConsumerTask)</span></span>;</div><div class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">consumer2</span><span class="params">(ConsumerTask)</span></span>;</div><div class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">consumer3</span><span class="params">(ConsumerTask)</span></span>;</div><div class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">consumer4</span><span class="params">(ConsumerTask)</span></span>;</div><div class="line">    producer1.join();</div><div class="line">    producer2.join();</div><div class="line">    producer3.join();</div><div class="line">    producer4.join();</div><div class="line">    consumer1.join();</div><div class="line">    consumer2.join();</div><div class="line">    consumer3.join();</div><div class="line">    consumer4.join();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>运行结果：</p>
<p><img src="http://oe9uinblw.bkt.clouddn.com/C++%E5%B9%B6%E5%8F%914.png" alt=""></p>
<hr>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/02/15/C++11 并发学习(四)/" class="archive-article-date">
  	<time datetime="2017-02-15T06:52:04.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-02-15</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/concurrency/">concurrency</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/threadpool/">threadpool</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="airticle-C++11 并发学习(三)" class="article article-type-airticle" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/14/C++11 并发学习(三)/">C++11 并发学习(三)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p></p><p><br><a href="http://www.cnblogs.com/haippy/p/3284540.html" target="_blank" rel="external">学习自大神博客</a></p>
<h2 id="C-11-ThreadPool-简单实现"><a href="#C-11-ThreadPool-简单实现" class="headerlink" title="C++11 ThreadPool 简单实现"></a>C++11 ThreadPool 简单实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> THREAD_POOL_H</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_POOL_H</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">// C++11 版的 线程池</span></div><div class="line"><span class="keyword">namespace</span> zl</div><div class="line">&#123;</div><div class="line">    <span class="keyword">class</span> ThreadsGuard</div><div class="line">    &#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        ThreadsGuard(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt;&amp; v)</div><div class="line">            : threads_(v)</div><div class="line">        &#123;</div><div class="line">            </div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ~ThreadsGuard()</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != threads_.size(); ++i)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span> (threads_[i].joinable())</div><div class="line">                &#123;</div><div class="line">                    threads_[i].join();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        ThreadsGuard(ThreadsGuard&amp;&amp; tg) = <span class="keyword">delete</span>;</div><div class="line">        ThreadsGuard&amp; <span class="keyword">operator</span> = (ThreadsGuard&amp;&amp; tg) = <span class="keyword">delete</span>;</div><div class="line"></div><div class="line">        ThreadsGuard(<span class="keyword">const</span> ThreadsGuard&amp;) = <span class="keyword">delete</span>;</div><div class="line">        ThreadsGuard&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> ThreadsGuard&amp;) = <span class="keyword">delete</span>;</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt;&amp; threads_;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">class</span> ThreadPool</div><div class="line">    &#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="keyword">typedef</span> <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; task_type;</div><div class="line"></div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">ThreadPool</span><span class="params">(<span class="keyword">int</span> n = <span class="number">0</span>)</span></span>;</div><div class="line"></div><div class="line">        ~ThreadPool()</div><div class="line">        &#123;</div><div class="line">            stop();</div><div class="line">            cond_.notify_all();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span></div><div class="line">        &#123;</div><div class="line">            stop_.store(<span class="literal">true</span>, <span class="built_in">std</span>::memory_order_release);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">template</span>&lt;<span class="keyword">class</span> Function, <span class="keyword">class</span>... Args&gt;</div><div class="line">        <span class="built_in">std</span>::future&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::result_of&lt;Function(Args...)&gt;::type&gt; add(Function&amp;&amp;, Args&amp;&amp;...);</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        ThreadPool(ThreadPool&amp;&amp;) = <span class="keyword">delete</span>;</div><div class="line">        ThreadPool&amp; <span class="keyword">operator</span> = (ThreadPool&amp;&amp;) = <span class="keyword">delete</span>;</div><div class="line">        ThreadPool(<span class="keyword">const</span> ThreadPool&amp;) = <span class="keyword">delete</span>;</div><div class="line">        ThreadPool&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> ThreadPool&amp;) = <span class="keyword">delete</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        <span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; stop_;</div><div class="line">        <span class="built_in">std</span>::mutex mtx_;</div><div class="line">        <span class="built_in">std</span>::condition_variable cond_;</div><div class="line"></div><div class="line">        <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;task_type&gt; tasks_;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; threads_;</div><div class="line">        zl::ThreadsGuard tg_;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">inline</span> ThreadPool::ThreadPool(<span class="keyword">int</span> n)</div><div class="line">        : stop_(<span class="literal">false</span>)</div><div class="line">        , tg_(threads_)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> nthreads = n;</div><div class="line">        <span class="keyword">if</span> (nthreads &lt;= <span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">            nthreads = <span class="built_in">std</span>::thread::hardware_concurrency();</div><div class="line">            nthreads = (nthreads == <span class="number">0</span> ? <span class="number">2</span> : nthreads);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != nthreads; ++i)</div><div class="line">        &#123;</div><div class="line">            threads_.push_back(<span class="built_in">std</span>::thread([<span class="keyword">this</span>]&#123;</div><div class="line">                <span class="keyword">while</span> (!stop_.load(<span class="built_in">std</span>::memory_order_acquire))</div><div class="line">                &#123;</div><div class="line">                    task_type task;</div><div class="line">                    &#123;</div><div class="line">                        <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; ulk(<span class="keyword">this</span>-&gt;mtx_);</div><div class="line">                        <span class="keyword">this</span>-&gt;cond_.wait(ulk, [<span class="keyword">this</span>]&#123; <span class="keyword">return</span> stop_.load(<span class="built_in">std</span>::memory_order_acquire) || !<span class="keyword">this</span>-&gt;tasks_.empty(); &#125;);</div><div class="line">                        <span class="keyword">if</span> (stop_.load(<span class="built_in">std</span>::memory_order_acquire))</div><div class="line">                            <span class="keyword">return</span>;</div><div class="line">                        task = <span class="built_in">std</span>::move(<span class="keyword">this</span>-&gt;tasks_.front());</div><div class="line">                        <span class="keyword">this</span>-&gt;tasks_.pop();</div><div class="line">                    &#125;</div><div class="line">                    task();</div><div class="line">                &#125;</div><div class="line">            &#125;));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> Function, <span class="keyword">class</span>... Args&gt;</div><div class="line">    <span class="built_in">std</span>::future&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::result_of&lt;Function(Args...)&gt;::type&gt;</div><div class="line">        ThreadPool::add(Function&amp;&amp; fcn, Args&amp;&amp;... args)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="built_in">std</span>::result_of&lt;Function(Args...)&gt;::type return_type;</div><div class="line">        <span class="keyword">typedef</span> <span class="built_in">std</span>::packaged_task&lt;return_type()&gt; task;</div><div class="line"></div><div class="line">        <span class="keyword">auto</span> t = <span class="built_in">std</span>::make_shared&lt;task&gt;(<span class="built_in">std</span>::bind(<span class="built_in">std</span>::forward&lt;Function&gt;(fcn), <span class="built_in">std</span>::forward&lt;Args&gt;(args)...));</div><div class="line">        <span class="keyword">auto</span> ret = t-&gt;get_future();</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lg(mtx_);</div><div class="line">            <span class="keyword">if</span> (stop_.load(<span class="built_in">std</span>::memory_order_acquire))</div><div class="line">                <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"thread pool has stopped"</span>);</div><div class="line">            tasks_.emplace([t]&#123;(*t)(); &#125;);</div><div class="line">        &#125;</div><div class="line">        cond_.notify_one();</div><div class="line">        <span class="keyword">return</span> ret;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">/* THREAD_POOL_H */</span></span></div></pre></td></tr></table></figure>
<hr>
<h2 id="线程池的具体思路就不多说了，我们主要说一下用到的-c-11-的部分"><a href="#线程池的具体思路就不多说了，我们主要说一下用到的-c-11-的部分" class="headerlink" title="线程池的具体思路就不多说了，我们主要说一下用到的 c++11 的部分"></a>线程池的具体思路就不多说了，我们主要说一下用到的 <strong>c++11</strong> 的部分</h2><h3 id="首先是建立了一个-std-vector-lt-std-thread-gt-amp-v-的容器"><a href="#首先是建立了一个-std-vector-lt-std-thread-gt-amp-v-的容器" class="headerlink" title="首先是建立了一个 std::vector&lt; std::thread&gt;&amp; v 的容器"></a>首先是建立了一个 std::vector&lt; std::thread&gt;&amp; v 的容器</h3><h3 id="定义了一个原子操作-std-atomic-lt-bool-gt-stop-对bool进行了原子性封装"><a href="#定义了一个原子操作-std-atomic-lt-bool-gt-stop-对bool进行了原子性封装" class="headerlink" title="定义了一个原子操作 std::atomic&lt; bool&gt; stop_  对bool进行了原子性封装"></a>定义了一个原子操作 std::atomic&lt; bool&gt; stop_  对bool进行了原子性封装</h3><h3 id="然后不仅用到了-std-lock-guard，还用了相比其提供了更好的上锁和解锁控制的-std-unique-lock。"><a href="#然后不仅用到了-std-lock-guard，还用了相比其提供了更好的上锁和解锁控制的-std-unique-lock。" class="headerlink" title="然后不仅用到了 std::lock_guard，还用了相比其提供了更好的上锁和解锁控制的 std::unique_lock。"></a>然后不仅用到了 std::lock_guard，还用了相比其提供了更好的上锁和解锁控制的 std::unique_lock。</h3><p>这里主要介绍一下操作更为丰富的 <strong>std::unique_lock</strong></p>
<blockquote>
<p>顾名思义，<strong>unique_lock</strong> 对象以独占所有权的方式（unique owership）管理 <strong>mutex</strong> 对象的上锁和解锁操作，所谓独占所有权，就是没有其他的 <strong>unique_lock</strong> 对象同时拥有某个 <strong>mutex</strong> 对象的所有权。</p>
</blockquote>
<p>  ①. 上锁/解锁操作：lock，try_lock，try_lock_for，try_lock_until 和 unlock</p>
<p>  ②. 修改操作：移动赋值(move assignment)(前面已经介绍过了)，交换(swap)（与另一个 std::unique_lock 对象交换它们所管理的 Mutex 对象的所有权），释放(release)（返回指向它所管理的 Mutex 对象的指针，并释放所有权）</p>
<p>  ③. 获取属性操作：owns_lock（返回当前 std::unique_lock 对象是否获得了锁）、operator bool()（与 owns_lock 功能相同，返回当前 std::unique_lock 对象是否获得了锁）、mutex（返回当前 std::unique_lock 对象所管理的 Mutex 对象的指针）。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><blockquote>
<p>感觉这个例子还是用到挺多 <strong>C++11</strong> 的特性，在这里还是得一一解释一下（只是简单解释一下，关于C++还有很多要学的，我目前也只是个菜鸡啊。。。 <strong>C++</strong> 太棒了！特性多到你学不完→→手动滑稽）：</p>
</blockquote>
<h3 id="首先是std-function"><a href="#首先是std-function" class="headerlink" title="首先是std::function"></a>首先是std::function</h3><p>简单的来说就是：</p>
<blockquote>
<p>通过std::function对 <strong>C++</strong> 中各种可调用实体（普通函数、Lambda表达式、函数指针、以及其它函数对象等）的封装，形成一个新的可调用的std::function对象；让我们不再纠结那么多的可调用实体。一切变的简单粗暴。</p>
</blockquote>
<p>其实就是以前我们用函数指针来统一处理不同的函数对象类型，现在我们可以使用更安全的std::function来完成这些任务。</p>
<p>在上述例子中，使用它来定义了一个任务类型对象</p>
<p>typedef std::function&lt; void()&gt; task_type;</p>
<p><a href="http://www.jellythink.com/archives/771" target="_blank" rel="external">更为深入地学习，可以看这篇博客</a></p>
<h3 id="std-memory-order"><a href="#std-memory-order" class="headerlink" title="std::memory_order"></a>std::memory_order</h3><p>C++11 中规定了6种访存次序(Memory Order)，<a href="https://www.zhihu.com/question/24301047" target="_blank" rel="external">知乎上给出了通俗的解释</a></p>
<ul>
<li>momory_order_relaxed,</li>
<li>memory_order_consume,</li>
<li>memory_order_acquire,</li>
<li>memory_order_release,</li>
<li>memory_order_acq_rel,</li>
<li>memory_order_seq_cst.</li>
</ul>
<blockquote>
<p>虽然有6个选项，其实表示的是三种内存模型</p>
</blockquote>
<ul>
<li><p>sequential consistent(memory_order_seq_cst)</p>
</li>
<li><p>relaxed(memory_order_seq_cst)</p>
</li>
<li><p>acquire release(memory_order_consume, memory_order_acquire, memory_order_release, memory_order_acq_rel) </p>
</li>
</ul>
<p>我们这里用到的是获取-释放次序 <em>acquire release</em></p>
<blockquote>
<p>目的就是限制两个来自不同线程的原子操作的顺序，具体的操作就是需要两个线程进行一下同步，同步对一个变量的读写操作…</p>
</blockquote>
<p>①. 原子 <strong>load</strong> 操作：</p>
<p>while (!stop_.load(std::memory_order_acquire))</p>
<p>②. 原子 <strong>store</strong> 操作：</p>
<p>std::memory_order_release</p>
<h3 id="std-result-of"><a href="#std-result-of" class="headerlink" title="std::result_of"></a>std::result_of</h3><p>其实这个就是和我们之前的auto decltype都是属于自动类型推导，主要是使我们的代码可读易维护</p>
<p>我们这里用的<br>std::future&lt; typename std::result_of&lt; Function(Args…)&gt;::type&gt; add(Function&amp;&amp;, Args&amp;&amp;…);<br>就是为了获取function的返回值</p>
<blockquote>
<p>result_of 其实就是通过decltype来推导函数的返回类型</p>
</blockquote>
<h3 id="std-move"><a href="#std-move" class="headerlink" title="std::move"></a>std::move</h3><p>在C++11中，标准库在&lt; utility&gt;中提供了一个有用的函数std::move，这个函数的名字具有迷惑性，因为实际上std::move并不能移动任何东西，它唯一的功能是将一个左值强制转化为右值引用，继而我们可以通过右值引用使用该值，以用于移动语义。从实现上讲，std::move基本等同于一个类型转换：<br>static_cast&lt; T&amp;&amp;&gt;(lvalue);</p>
<blockquote>
<p>值得一提的是，被转化的左值，其生命期并没有随着左右值的转化而改变。如果读者期望std::move转化的左值变量lvalue能立即被析构，那么肯定会失望了。</p>
</blockquote>
<h3 id="std-packaged-task"><a href="#std-packaged-task" class="headerlink" title="std::packaged_task"></a>std::packaged_task</h3><p>std::packaged_task它包装了一个可调用的目标（如function, lambda expression, bind expression, or another function object）,以便异步调用，它和promise在某种程度上有点像，promise保存了一个共享状态的值，而packaged_task保存的是一个函数</p>
<p>typedef std::packaged_task&lt; return_type()&gt; task;</p>
<h3 id="std-make-shared"><a href="#std-make-shared" class="headerlink" title="std::make_shared"></a>std::make_shared</h3><p>C++11 中引入了智能指针, 同时还有一个模板函数 std::make_shared 可以返回一个指定类型的 std::shared_ptr：</p>
<p>struct A;<br>std::shared_ptr&lt; A&gt; p1 = std::make_shared&lt; A&gt;();<br>std::shared_ptr&lt; A&gt; p2(new A);</p>
<p>①. 如果是使用 <strong>new</strong> ：</p>
<p>auto p = new widget();<br>shared_ptr sp1{ p }, sp2{ sp1 };<br>需要两次内存分配</p>
<p>②. 然而使用 <strong>make_shared</strong> 的话：</p>
<p>auto sp1 = make_shared(), sp2{ sp1 };</p>
<p>所以我们这里 <strong>std::make_shared</strong> 其实就是为了代替 <strong>new</strong><br>auto t = std::make_shared&lt; task&gt;(std::bind(std::forward&lt; Function&gt;(fcn), std::forward&lt; Args&gt;(args)…));</p>
<p><a href="http://www.tuicool.com/articles/F3u6jy" target="_blank" rel="external">想要进一步了解它与std::shared_ptr的构造函数比较的戳</a></p>
<p>总结一些我们需要了解的就是：</p>
<p>①. 同直接使用new相比，make函数减小了代码重复，提高的异常安全，并且对于std::make_shared和std::allcoated_shared，生成的代码会更小更快。</p>
<p>②. 不能使用make函数的情况包括我们需要定制删除器和期望直接传递大括号初始化器。</p>
<p>③. 对于std::shared_ptr，额外的不建议使用make函数的情况包括：<br>（1）定制内存管理的类<br>（2）关注内存的系统，非常大的对象，以及生存期比 std::shared_ptr长的std::weak_ptr</p>
<p>下一篇我们将会实现C++11多线程下各种生产者消费者模型</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/02/14/C++11 并发学习(三)/" class="archive-article-date">
  	<time datetime="2017-02-14T04:02:34.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-02-14</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/concurrency/">concurrency</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/threadpool/">threadpool</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="airticle-C++11 并发学习(二)" class="article article-type-airticle" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/14/C++11 并发学习(二)/">C++11 并发学习(二)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p></p><p><br><a href="http://www.cnblogs.com/haippy/p/3284540.html" target="_blank" rel="external">学习自大神博客</a></p>
<h2 id="线程详解"><a href="#线程详解" class="headerlink" title="线程详解"></a>线程详解</h2><p>具体源码的大家有兴趣的可以去查看<a href="http://www.open-std.org/" target="_blank" rel="external">c++ 标准委员会的官方文档</a></p>
<p>在这里我主要讲一下他们的主要结构以及主要用法</p>
<h3 id="lt-thread-gt"><a href="#lt-thread-gt" class="headerlink" title="&lt; thread&gt;"></a>&lt; thread&gt;</h3><ol>
<li>std::thread 简单例子</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span> <span class="comment">// std::cout</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span>   <span class="comment">// std::thread</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_task</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello thread"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t</span><span class="params">(thread_task)</span></span>;</div><div class="line">    t.join();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="lt-mutex-gt"><a href="#lt-mutex-gt" class="headerlink" title="&lt; mutex&gt;"></a>&lt; mutex&gt;</h3><blockquote>
<p>std::mutex 是C++11 中最基本的互斥量，std::mutex 对象提供了独占所有权的特性——即不支持递归地对 std::mutex 对象上锁，而 std::recursive_lock 则可以递归地对互斥量对象上锁。</p>
</blockquote>
<p>①. <strong>Mutex</strong> 系列类(四种)</p>
<ul>
<li>std::mutex，最基本的 Mutex 类。</li>
<li>std::recursive_mutex，递归 Mutex 类。</li>
<li>std::time_mutex，定时 Mutex 类。</li>
<li>std::recursive_timed_mutex，定时递归 Mutex 类</li>
</ul>
<p>②. <strong>Lock</strong> 类（两种）</p>
<ul>
<li>std::lock_guard，与 Mutex RAII （资源获取即初始化）相关，方便线程对互斥量上锁。</li>
<li>std::unique_lock，与 Mutex RAII （资源获取即初始化）相关，方便线程对互斥量上锁，但提供了更好的上锁和解锁控制。</li>
</ul>
<h3 id="lt-condition-variable-gt"><a href="#lt-condition-variable-gt" class="headerlink" title="&lt; condition_variable&gt;"></a>&lt; condition_variable&gt;</h3><blockquote>
<p>&lt; condition_variable &gt; 头文件主要包含了与条件变量相关的类和函数。与条件变量相关的类包括 std::condition_variable 和 std::condition_variable_any，还有枚举类型std::cv_status。另外还包括函数 std::notify_all_at_thread_exit()</p>
<p>在 <strong>Linux</strong> 下是使用 <strong>Pthread</strong> 库中的 <strong>pthread<em>cond</em>*() </strong> 函数来实现条件变量相关的功能</p>
</blockquote>
<h3 id="lt-future-gt"><a href="#lt-future-gt" class="headerlink" title="&lt; future&gt;"></a>&lt; future&gt;</h3><blockquote>
<p>C++11 标准中与异步任务系相关的类型主要是以下四种 std::promise，std::packaged_task（std::promise，std::packaged_task 也称为异步任务的提供者 Provider，此外 std::async 也可以作为异步任务的提供者，不过 std::async 并不是类，而是函数，本章后面会详细介绍异步任务的提供者 Provider），std::future，std::shared_future。另外 &lt; future&gt; 中还定义一些辅助的类，例如： std::future_error，std::future_errc，std::status，std::launch。</p>
</blockquote>
<p>之前也有提到，主要是用来实现异步</p>
<h3 id="lt-atomic-gt"><a href="#lt-atomic-gt" class="headerlink" title="&lt; atomic&gt;"></a>&lt; atomic&gt;</h3><p>关于C++11的原子操作之前我有过笔记，下图</p>
<p><img src="http://oe9uinblw.bkt.clouddn.com/WechatIMG2.jpeg" alt=""></p>
<p>好了，关于 <strong>C++11</strong> 的新特性大致的梳理了一遍，接下来我们先看看之前提到的那个 <strong>C++11</strong> 的线程池具体是怎么实现的吧</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/02/14/C++11 并发学习(二)/" class="archive-article-date">
  	<time datetime="2017-02-13T17:02:34.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-02-14</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/concurrency/">concurrency</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/thread/">thread</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="airticle-C++11 并发学习(一)" class="article article-type-airticle" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/13/C++11 并发学习(一)/">C++11 并发学习(一)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p></p><p><br><a href="http://www.cnblogs.com/haippy/p/3284540.html" target="_blank" rel="external">学习自大神博客</a></p>
<h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2><blockquote>
<p>与并发相近的另一个概念是并行(Parallel)。和并发所描述的情况一样，并行也是指两个或多个任务被同时执行。但是严格来讲，并发和并行的概念并是不等同的，两者存在很大的差别。下面我们来看看计算机科学家们是怎么区分并发和并行的。</p>
<p>并发是一个处理器同时处理多个任务，而并行是多个处理器或者是多核的处理器同时处理多个不同的任务。前者是逻辑上的同时发生（simultaneous），而后者是物理上的同时发生。</p>
</blockquote>
<h2 id="C-并发"><a href="#C-并发" class="headerlink" title="C++并发"></a>C++并发</h2><h3 id="C-11多线程相关的头文件"><a href="#C-11多线程相关的头文件" class="headerlink" title="C++11多线程相关的头文件"></a>C++11多线程相关的头文件</h3><blockquote>
<p>C++11 新标准中引入了五个头文件来支持多线程编程，它们分别是 &lt; atomic&gt;, &lt; thread&gt;, &lt; mutex&gt;, &lt; condition_variable&gt; 和 &lt; future&gt;。</p>
</blockquote>
<p>①. &lt; atomic&gt;：该头文主要声明了两个类, std::atomic 和 std::atomic_flag，另外还声明了一套 C 风格的原子类型和与 C 兼容的原子操作的函数。<br>&lt; atomic&gt; 一一 可以用来实现数据结构的无锁结构</p>
<p>②. &lt; thread&gt;：该头文件主要声明了 std::thread 类，另外 std::this_thread 命名空间也在该头文件中。<br>之前在Linux下写多线程的时候用的Pthread，但是在实现线程池的时候，有用到过C++11的<thread>，具体是学习自<a href="https://github.com/lizhenghn123/zl_threadpool" target="_blank" rel="external">这个大神的C++的线程池demo</a></thread></p>
<p>③. &lt; mutex&gt;：该头文件主要声明了与互斥量(Mutex)相关的类，包括 std::mutex_* 一系列类，std::lock_guard, std::unique_lock, 以及其他的类型和函数。</p>
<p>④. &lt; condition_variable&gt;：该头文件主要声明了与条件变量相关的类，包括 std::condition_variable 和 std::condition_variable_any。</p>
<p>⑤. &lt; future&gt;：该头文件主要声明了 std::promise, std::package_task 两个 Provider 类，以及 std::future 和 std::shared_future 两个 Future 类，另外还有一些与之相关的类型和函数，std::async() 函数就声明在此头文件中。<br>这里介绍一下std::async() 一一 用来优雅的实现C++异步，一般和std::future()一起使用，前者用于创建异步任务，后者从异步任务中获取结果。</p>
<p>接下来我们就是要具体地学习每一个部分了，不过大部分就是之前学习过，用过的，应该学起来还是很快的。</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/02/13/C++11 并发学习(一)/" class="archive-article-date">
  	<time datetime="2017-02-13T02:58:34.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-02-13</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/concurrency/">concurrency</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/thread/">thread</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  


      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 kelele67
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
<script type="text/javascript">
var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1260501136'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1260501136%26online%3D1%26show%3Dline' type='text/javascript'%3E%3C/script%3E"));
</script>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/"
	}
</script>

<script src="/./main.js"></script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<a href="/tags/CRT/" style="font-size: 14px;">CRT</a> <a href="/tags/algorithm/" style="font-size: 16px;">algorithm</a> <a href="/tags/animation/" style="font-size: 14px;">animation</a> <a href="/tags/buffer-manipulation/" style="font-size: 10px;">buffer manipulation</a> <a href="/tags/c/" style="font-size: 20px;">c</a> <a href="/tags/c/" style="font-size: 18px;">c++</a> <a href="/tags/ccache/" style="font-size: 10px;">ccache</a> <a href="/tags/cgroup/" style="font-size: 10px;">cgroup</a> <a href="/tags/concurrency/" style="font-size: 16px;">concurrency</a> <a href="/tags/data-structures/" style="font-size: 10px;">data structures</a> <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/gc/" style="font-size: 16px;">gc</a> <a href="/tags/hash/" style="font-size: 10px;">hash</a> <a href="/tags/html5/" style="font-size: 10px;">html5</a> <a href="/tags/http/" style="font-size: 12px;">http</a> <a href="/tags/ios/" style="font-size: 10px;">ios</a> <a href="/tags/leetcode/" style="font-size: 10px;">leetcode</a> <a href="/tags/linux/" style="font-size: 18px;">linux</a> <a href="/tags/lua/" style="font-size: 16px;">lua</a> <a href="/tags/make/" style="font-size: 10px;">make</a> <a href="/tags/mount/" style="font-size: 12px;">mount</a> <a href="/tags/namespace/" style="font-size: 10px;">namespace</a> <a href="/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/tags/python/" style="font-size: 16px;">python</a> <a href="/tags/release/" style="font-size: 10px;">release</a> <a href="/tags/search/" style="font-size: 10px;">search</a> <a href="/tags/siri/" style="font-size: 10px;">siri</a> <a href="/tags/solution/" style="font-size: 10px;">solution</a> <a href="/tags/sort/" style="font-size: 12px;">sort</a> <a href="/tags/string-manipulation/" style="font-size: 10px;">string manipulation</a> <a href="/tags/swift/" style="font-size: 14px;">swift</a> <a href="/tags/systemd/" style="font-size: 10px;">systemd</a> <a href="/tags/sysvinit/" style="font-size: 10px;">sysvinit</a> <a href="/tags/tcp/" style="font-size: 10px;">tcp</a> <a href="/tags/thread/" style="font-size: 12px;">thread</a> <a href="/tags/threadpool/" style="font-size: 12px;">threadpool</a> <a href="/tags/tmpfs/" style="font-size: 10px;">tmpfs</a> <a href="/tags/trees/" style="font-size: 10px;">trees</a> <a href="/tags/ubuntu/" style="font-size: 10px;">ubuntu</a> <a href="/tags/udp/" style="font-size: 10px;">udp</a> <a href="/tags/upstart/" style="font-size: 10px;">upstart</a> <a href="/tags/web-server/" style="font-size: 10px;">web server</a> <a href="/tags/zookeeper/" style="font-size: 12px;">zookeeper</a> <a href="/tags/随笔/" style="font-size: 10px;">随笔</a> <a href="/tags/面试/" style="font-size: 10px;">面试</a>
    			</div>
    	</section>
    

    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">&lt;div class=&quot;text&quot; style=&quot; text-align:center;&quot;&gt;大三学生&lt;br&gt;就读于重庆大学 软件狗&lt;br&gt;&lt;br&gt; 喜欢python&lt;br&gt;自由的灵魂&lt;br&gt;&lt;br&gt;世界万物都是隐喻&lt;br&gt;我们是通过隐喻这个装置接受反讽&lt;br&gt;加深扩大自己&lt;/div&gt;</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>
